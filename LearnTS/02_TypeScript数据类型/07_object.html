<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TypeScript object 类型详解</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      body {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #333;
        line-height: 1.6;
        padding: 20px;
        min-height: 100vh;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        margin-bottom: 40px;
        padding: 30px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      }

      h1 {
        color: #2c3e50;
        margin-bottom: 15px;
        font-size: 2.5rem;
      }

      .subtitle {
        color: #7f8c8d;
        font-size: 1.2rem;
      }

      .content-wrapper {
        display: flex;
        flex-direction: column;
        flex-wrap: wrap;
        gap: 30px;
        margin-bottom: 40px;
      }

      .explanation {
        flex: 1;
        min-width: 350px;
        background: rgba(255, 255, 255, 0.95);
        padding: 25px;
        border-radius: 12px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        margin-bottom: 40px;
      }

      .demo-area {
        flex: 1;
        min-width: 350px;
        background: rgba(255, 255, 255, 0.95);
        padding: 25px;
        border-radius: 12px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      }

      h2 {
        color: #667eea;
        margin: 20px 0 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid #f0f0f0;
      }

      h3 {
        color: #2c3e50;
        margin: 15px 0 10px;
      }

      p {
        margin-bottom: 15px;
      }

      .code-example {
        background: #2c3e50;
        color: #ecf0f1;
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
        overflow-x: auto;
        font-family: "Courier New", monospace;
        line-height: 1.5;
        border-left: 4px solid #667eea;
      }

      .comparison-table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .comparison-table th,
      .comparison-table td {
        border: 1px solid #ddd;
        padding: 12px;
        text-align: left;
      }

      .comparison-table th {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        font-weight: 600;
      }

      .comparison-table tr:nth-child(even) {
        background-color: #f9f9f9;
      }

      .type-hierarchy {
        background: #f8f9fa;
        padding: 25px;
        border-radius: 10px;
        margin: 20px 0;
        border: 2px solid #667eea;
      }

      .hierarchy-level {
        margin: 15px 0;
        padding: 15px;
        background: white;
        border-radius: 6px;
        border-left: 4px solid #4ecdc4;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .demo-container {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
        border: 2px solid #e9ecef;
      }

      .demo-result {
        background: #2c3e50;
        color: #ecf0f1;
        padding: 15px;
        border-radius: 6px;
        margin: 10px 0;
        font-family: "Courier New", monospace;
        min-height: 100px;
      }

      .controls {
        display: flex;
        gap: 10px;
        margin-top: 20px;
        flex-wrap: wrap;
      }

      button {
        padding: 10px 15px;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: bold;
        flex: 1;
        min-width: 120px;
      }

      button:hover {
        background: #5a6fd8;
        transform: translateY(-2px);
      }

      .note {
        background: #fff8e1;
        padding: 15px;
        border-radius: 6px;
        border-left: 4px solid #ffc107;
        margin: 20px 0;
      }

      .warning {
        background: #ffebee;
        padding: 15px;
        border-radius: 6px;
        border-left: 4px solid #f44336;
        margin: 20px 0;
      }

      .success {
        background: #e8f5e9;
        padding: 15px;
        border-radius: 6px;
        border-left: 4px solid #4caf50;
        margin: 20px 0;
      }

      .usage-scenarios {
        display: grid;
        grid-template-columns: 1fr;
        gap: 20px;
        margin: 20px 0;
      }

      .scenario-card {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        border-left: 4px solid #667eea;
      }

      .type-comparison {
        display: flex;
        gap: 20px;
        margin: 20px 0;
      }

      .type-column {
        flex: 1;
        min-width: 300px;
      }

      .type-header {
        background: #667eea;
        color: white;
        padding: 10px;
        border-radius: 6px 6px 0 0;
        font-weight: bold;
        text-align: center;
      }

      .type-content {
        background: #2c3e50;
        color: #ecf0f1;
        padding: 15px;
        border-radius: 0 0 6px 6px;
        font-family: "Courier New", monospace;
        overflow-x: auto;
      }

      .object-type {
        border-left: 4px solid #4caf50;
      }

      .any-type {
        border-left: 4px solid #f44336;
      }

      .unknown-type {
        border-left: 4px solid #ffc107;
      }

      .property-access-demo {
        background: #e3f2fd;
        padding: 20px;
        border-radius: 8px;
        margin: 20px 0;
        border: 2px solid #2196f3;
      }

      .access-step {
        margin: 10px 0;
        padding: 10px;
        background: white;
        border-radius: 4px;
        border-left: 3px solid #2196f3;
      }

      footer {
        text-align: center;
        margin-top: 40px;
        padding: 20px;
        color: white;
        font-size: 0.9rem;
      }

      @media (max-width: 768px) {
        .content-wrapper {
          flex-direction: column;
        }

        .type-comparison {
          flex-direction: column;
        }
      }

      .memory-model {
        display: flex;
        align-items: center;
        justify-content: space-around;
        margin: 20px 0;
        padding: 20px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .variable {
        text-align: center;
      }

      .arrow {
        font-size: 1.5rem;
        color: #667eea;
      }

      .memory-block {
        padding: 15px;
        background: #f8f9fa;
        border-radius: 6px;
        border: 2px solid #667eea;
        min-width: 150px;
      }

      .type-relationships {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin: 20px 0;
      }

      .relationship-card {
        flex: 1;
        min-width: 200px;
        padding: 15px;
        background: white;
        border-radius: 6px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>TypeScript object 类型详解</h1>
        <p class="subtitle">深入理解非原始类型的表示与使用</p>
      </header>

      <div class="content-wrapper">
        <div class="explanation">
          <h2>什么是 object 类型？</h2>

          <p>在 TypeScript 中，<code>object</code> 类型表示<strong>非原始类型</strong>的值，即不是 <code>number</code>, <code>string</code>, <code>boolean</code>, <code>symbol</code>, <code>null</code>, 或 <code>undefined</code> 的任何值。</p>

          <div class="code-example">
            // object 类型的基本用法<br />
            let obj: object;<br /><br />

            obj = { name: 'John' }; // ✅ 允许 - 普通对象<br />
            obj = [1, 2, 3]; // ✅ 允许 - 数组<br />
            obj = new Date(); // ✅ 允许 - Date 对象<br />
            obj = function() {}; // ✅ 允许 - 函数<br />
            obj = /regex/; // ✅ 允许 - 正则表达式<br /><br />

            obj = 42; // ❌ 错误 - 原始类型 number<br />
            obj = 'hello'; // ❌ 错误 - 原始类型 string<br />
            obj = true; // ❌ 错误 - 原始类型 boolean
          </div>

          <div class="note">
            <strong>核心特性：</strong><br />
            • 表示任何非原始类型的值<br />
            • 不包括原始类型（number, string, boolean 等）<br />
            • 是一个宽泛的类型，不包含具体属性信息<br />
            • 需要类型收窄才能安全访问属性
          </div>

          <h3>类型层次结构</h3>

          <div class="type-hierarchy">
            <div class="hierarchy-level"><strong>any</strong> - 任何类型（最宽泛）</div>
            <div class="hierarchy-level"><strong>unknown</strong> - 未知类型（需要检查）</div>
            <div class="hierarchy-level"><strong>object</strong> - 非原始类型</div>
            <div class="hierarchy-level"><strong>具体对象类型</strong> - { name: string } 等（最具体）</div>
          </div>
        </div>

        <div class="demo-area">
          <h2>object vs Object vs {}</h2>

          <div class="type-comparison">
            <div class="type-column">
              <div class="type-header object-type">object</div>
              <div class="type-content">
                // 非原始类型<br />
                let a: object;<br /><br />

                a = {}; // ✅<br />
                a = []; // ✅<br />
                a = () => {}; // ✅<br />
                a = 123; // ❌<br />
                a = 'hello'; // ❌
              </div>
            </div>

            <div class="type-column">
              <div class="type-header">Object / {}</div>
              <div class="type-content">
                // 任何有值的类型<br />
                let b: {};<br /><br />

                b = {}; // ✅<br />
                b = []; // ✅<br />
                b = () => {}; // ✅<br />
                b = 123; // ✅<br />
                b = 'hello'; // ✅<br />
                b = null; // ❌<br />
                b = undefined; // ❌
              </div>
            </div>
          </div>

          <div class="demo-container">
            <h3>类型检测演示</h3>
            <div class="demo-result" id="typeDetectionDemo">// 测试各种值是否可以被赋给 object 类型</div>
            <div class="controls">
              <button onclick="testObjectAssignment()">测试赋值</button>
              <button onclick="testPropertyAccess()">测试属性访问</button>
              <button onclick="clearDemo()">清空演示</button>
            </div>
          </div>
        </div>
      </div>

      <table class="comparison-table">
        <tr>
          <th>类型</th>
          <th>描述</th>
          <th>包含原始类型</th>
          <th>包含对象类型</th>
          <th>使用场景</th>
        </tr>
        <tr>
          <td><strong>object</strong></td>
          <td>非原始类型</td>
          <td>❌ 不包含</td>
          <td>✅ 包含</td>
          <td>处理未知对象结构</td>
        </tr>
        <tr>
          <td><strong>Object / {}</strong></td>
          <td>任何非空值</td>
          <td>✅ 包含</td>
          <td>✅ 包含</td>
          <td>很少使用</td>
        </tr>
        <tr>
          <td><strong>any</strong></td>
          <td>任何类型</td>
          <td>✅ 包含</td>
          <td>✅ 包含</td>
          <td>迁移旧代码</td>
        </tr>
        <tr>
          <td><strong>unknown</strong></td>
          <td>未知类型</td>
          <td>✅ 包含</td>
          <td>✅ 包含</td>
          <td>安全处理动态数据</td>
        </tr>
      </table>

      <div class="content-wrapper">
        <div class="explanation">
          <h2>object 类型的使用场景</h2>

          <div class="usage-scenarios">
            <div class="scenario-card">
              <h4>📦 通用对象容器</h4>
              <p>当需要存储对象但不确定具体结构时</p>
              <div class="code-example">
                function storeObject(obj: object): void {<br />
                &nbsp;&nbsp;// 可以接受任何对象<br />
                &nbsp;&nbsp;localStorage.setItem('data', JSON.stringify(obj));<br />
                }
              </div>
            </div>

            <div class="scenario-card">
              <h4>🔄 对象操作函数</h4>
              <p>编写处理各种对象的通用工具函数</p>
              <div class="code-example">
                function getObjectKeys(obj: object): string[] {<br />
                &nbsp;&nbsp;return Object.keys(obj);<br />
                }<br /><br />

                getObjectKeys({ a: 1, b: 2 }); // ✅<br />
                getObjectKeys([1, 2, 3]); // ✅<br />
                getObjectKeys(new Date()); // ✅
              </div>
            </div>

            <div class="scenario-card">
              <h4>🎯 事件处理</h4>
              <p>处理 DOM 事件或其他框架的事件对象</p>
              <div class="code-example">
                function handleEvent(event: object): void {<br />
                &nbsp;&nbsp;// 处理各种事件对象<br />
                &nbsp;&nbsp;console.log('Event received:', event);<br />
                }<br /><br />

                document.addEventListener('click', (e) => {<br />
                &nbsp;&nbsp;handleEvent(e); // MouseEvent 是 object<br />
                });
              </div>
            </div>
          </div>

          <h3>属性访问的限制</h3>

          <div class="property-access-demo">
            <h4>object 类型的属性访问</h4>

            <div class="access-step">
              <strong>直接访问属性 - 不允许</strong>
              <div class="code-example">
                function printName(obj: object) {<br />
                &nbsp;&nbsp;// 编译错误：Property 'name' does not exist on type 'object'<br />
                &nbsp;&nbsp;console.log(obj.name); // ❌ 错误<br />
                }
              </div>
            </div>

            <div class="access-step">
              <strong>类型断言 - 允许但危险</strong>
              <div class="code-example">
                function printName(obj: object) {<br />
                &nbsp;&nbsp;// 使用类型断言（需要确保类型正确）<br />
                &nbsp;&nbsp;console.log((obj as any).name); // ✅ 编译通过<br />
                &nbsp;&nbsp;// 但如果 obj 没有 name 属性，运行时可能出错<br />
                }
              </div>
            </div>

            <div class="access-step">
              <strong>类型收窄 - 推荐方式</strong>
              <div class="code-example">
                function printName(obj: object) {<br />
                &nbsp;&nbsp;// 先检查属性是否存在<br />
                &nbsp;&nbsp;if ('name' in obj) {<br />
                &nbsp;&nbsp;&nbsp;&nbsp;// TypeScript 知道 obj 有 name 属性<br />
                &nbsp;&nbsp;&nbsp;&nbsp;console.log(obj.name); // ✅ 安全<br />
                &nbsp;&nbsp;}<br />
                }
              </div>
            </div>
          </div>
        </div>

        <div class="demo-area">
          <h2>实际应用示例</h2>

          <div class="demo-container">
            <h3>配置对象处理</h3>
            <div class="code-example">
              // 处理动态配置对象<br />
              function mergeConfigs(<br />
              &nbsp;&nbsp;defaultConfig: object,<br />
              &nbsp;&nbsp;userConfig: object<br />
              ): object {<br />
              &nbsp;&nbsp;return {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;...defaultConfig,<br />
              &nbsp;&nbsp;&nbsp;&nbsp;...userConfig<br />
              &nbsp;&nbsp;};<br />
              }<br /><br />

              // 使用示例<br />
              const defaultAppConfig = {<br />
              &nbsp;&nbsp;theme: 'light',<br />
              &nbsp;&nbsp;language: 'en'<br />
              };<br /><br />

              const userPreferences = {<br />
              &nbsp;&nbsp;theme: 'dark'<br />
              };<br /><br />

              const finalConfig = mergeConfigs(defaultAppConfig, userPreferences);
            </div>
          </div>

          <div class="demo-container">
            <h3>对象验证函数</h3>
            <div class="code-example">
              // 验证对象是否包含特定属性<br />
              function hasProperty(obj: object, prop: string): boolean {<br />
              &nbsp;&nbsp;return prop in obj;<br />
              }<br /><br />

              // 类型安全的属性获取<br />
              function getProperty&lt;T&gt;(<br />
              &nbsp;&nbsp;obj: object,<br />
              &nbsp;&nbsp;prop: string,<br />
              &nbsp;&nbsp;defaultValue: T<br />
              ): T {<br />
              &nbsp;&nbsp;if (hasProperty(obj, prop)) {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;return (obj as any)[prop];<br />
              &nbsp;&nbsp;}<br />
              &nbsp;&nbsp;return defaultValue;<br />
              }<br /><br />

              // 使用示例<br />
              const data = { name: 'John', age: 30 };<br />
              const name = getProperty(data, 'name', 'Unknown'); // John<br />
              const email = getProperty(data, 'email', 'none@example.com'); // none@example.com
            </div>
          </div>
        </div>
      </div>

      <div class="content-wrapper">
        <div class="explanation">
          <h2>最佳实践和模式</h2>

          <h3>1. 优先使用具体类型</h3>
          <div class="type-comparison">
            <div class="type-column">
              <div class="type-header">不推荐 - 过于宽泛</div>
              <div class="type-content">
                function processUser(user: object) {<br />
                &nbsp;&nbsp;// 需要频繁的类型断言<br />
                &nbsp;&nbsp;const name = (user as any).name;<br />
                &nbsp;&nbsp;const age = (user as any).age;<br />
                }
              </div>
            </div>

            <div class="type-column">
              <div class="type-header object-type">推荐 - 具体类型</div>
              <div class="type-content">
                interface User {<br />
                &nbsp;&nbsp;name: string;<br />
                &nbsp;&nbsp;age: number;<br />
                }<br /><br />

                function processUser(user: User) {<br />
                &nbsp;&nbsp;// 类型安全，无需断言<br />
                &nbsp;&nbsp;const name = user.name;<br />
                &nbsp;&nbsp;const age = user.age;<br />
                }
              </div>
            </div>
          </div>

          <h3>2. 使用泛型约束</h3>
          <div class="code-example">
            // 使用泛型约束代替 object<br />
            function processObject&lt;T extends object&gt;(obj: T): T {<br />
            &nbsp;&nbsp;// T 是具体的对象类型<br />
            &nbsp;&nbsp;return { ...obj, processed: true };<br />
            }<br /><br />

            // 使用示例<br />
            const user = { name: 'John', age: 30 };<br />
            const processedUser = processObject(user);<br />
            // processedUser 的类型是 { name: string; age: number; processed: boolean }
          </div>

          <h3>3. 类型保护模式</h3>
          <div class="code-example">
            // 创建类型保护函数<br />
            function isRecord(obj: unknown): obj is Record&lt;string, unknown&gt; {<br />
            &nbsp;&nbsp;return typeof obj === 'object' && obj !== null;<br />
            }<br /><br />

            function safeAccess(obj: unknown, key: string): unknown {<br />
            &nbsp;&nbsp;if (isRecord(obj) && key in obj) {<br />
            &nbsp;&nbsp;&nbsp;&nbsp;return obj[key];<br />
            &nbsp;&nbsp;}<br />
            &nbsp;&nbsp;return undefined;<br />
            }
          </div>
        </div>

        <div class="demo-area">
          <h2>高级用法</h2>

          <div class="demo-container">
            <h3>索引签名与 object</h3>
            <div class="code-example">
              // 使用索引签名的对象类型<br />
              interface StringDictionary {<br />
              &nbsp;&nbsp;[key: string]: string;<br />
              }<br /><br />

              // 比 object 更具体，但仍然灵活<br />
              function processDictionary(dict: StringDictionary): void {<br />
              &nbsp;&nbsp;// 可以安全地访问字符串属性<br />
              &nbsp;&nbsp;for (const key in dict) {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;console.log(`${key}: ${dict[key]}`);<br />
              &nbsp;&nbsp;}<br />
              }<br /><br />

              // 使用示例<br />
              const colors: StringDictionary = {<br />
              &nbsp;&nbsp;primary: 'blue',<br />
              &nbsp;&nbsp;secondary: 'green'<br />
              };<br />
              processDictionary(colors);
            </div>
          </div>

          <div class="demo-container">
            <h3>Record 工具类型</h3>
            <div class="code-example">
              // 使用 Record 类型代替 object<br />
              type AppConfig = Record&lt;string, unknown&gt;;<br /><br />

              function validateConfig(config: AppConfig): boolean {<br />
              &nbsp;&nbsp;// 可以访问属性，但值是 unknown<br />
              &nbsp;&nbsp;return 'apiUrl' in config && typeof config.apiUrl === 'string';<br />
              }<br /><br />

              // 更具体的 Record<br />
              type UserData = Record&lt;'name' | 'email', string&gt;;<br />
              const user: UserData = {<br />
              &nbsp;&nbsp;name: 'John',<br />
              &nbsp;&nbsp;email: 'john@example.com'<br />
              };
            </div>
          </div>

          <div class="success">
            <strong>总结：</strong><br />
            • 使用 <code>object</code> 当需要表示任何非原始类型时<br />
            • 优先使用具体接口或类型别名<br />
            • 使用泛型约束获得更好的类型安全<br />
            • 使用类型保护安全地访问属性
          </div>
        </div>
      </div>

      <div class="content-wrapper">
        <div class="explanation">
          <h2>与其他类型的关系</h2>

          <div class="type-relationships">
            <div class="relationship-card">
              <h4>object 🆚 any</h4>
              <p><code>object</code> 更安全，排除原始类型</p>
            </div>

            <div class="relationship-card">
              <h4>object 🆚 unknown</h4>
              <p><code>unknown</code> 包含原始类型，需要更多检查</p>
            </div>

            <div class="relationship-card">
              <h4>object 🆚 Record</h4>
              <p><code>Record</code> 更具体，定义键值类型</p>
            </div>

            <div class="relationship-card">
              <h4>object 🆚 interface</h4>
              <p>接口提供完整的类型信息</p>
            </div>
          </div>

          <h3>内存模型理解</h3>

          <div class="memory-model">
            <div class="variable">
              <div>let obj: object</div>
              <div class="memory-block">
                📦 对象引用<br />
                (指向堆内存)
              </div>
            </div>

            <div class="arrow">→</div>

            <div class="memory-block">
              🗃️ 堆内存<br />
              { name: 'John' }<br />
              [1, 2, 3]<br />
              function() {}<br />
              new Date()
            </div>

            <div class="arrow">❌</div>

            <div class="memory-block">
              🔢 原始值<br />
              42, 'hello', true<br />
              (不允许)
            </div>
          </div>
        </div>

        <div class="demo-area">
          <h2>常见陷阱和解决方案</h2>

          <div class="demo-container">
            <h3>陷阱：过度使用 object</h3>
            <div class="code-example">
              // ❌ 不好的做法 - 过度使用 object<br />
              function handleData(data: object) {<br />
              &nbsp;&nbsp;// 需要大量类型断言<br />
              &nbsp;&nbsp;if ((data as any).type === 'user') {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;console.log((data as any).name);<br />
              &nbsp;&nbsp;}<br />
              }<br /><br />

              // ✅ 好的做法 - 使用联合类型<br />
              type Data =<br />
              &nbsp;&nbsp;| { type: 'user'; name: string }<br />
              &nbsp;&nbsp;| { type: 'product'; title: string };<br /><br />

              function handleData(data: Data) {<br />
              &nbsp;&nbsp;// 类型安全的处理<br />
              &nbsp;&nbsp;if (data.type === 'user') {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;console.log(data.name); // 自动类型收窄<br />
              &nbsp;&nbsp;}<br />
              }
            </div>
          </div>

          <div class="demo-container">
            <h3>解决方案：渐进式类型化</h3>
            <div class="code-example">
              // 1. 从 object 开始<br />
              function processInput(input: object) {<br />
              &nbsp;&nbsp;return input;<br />
              }<br /><br />

              // 2. 添加基本约束<br />
              function processInput&lt;T extends object&gt;(input: T): T {<br />
              &nbsp;&nbsp;return input;<br />
              }<br /><br />

              // 3. 最终使用具体类型<br />
              interface ProcessedInput {<br />
              &nbsp;&nbsp;id: string;<br />
              &nbsp;&nbsp;data: unknown;<br />
              }<br /><br />

              function processInput(input: object): ProcessedInput {<br />
              &nbsp;&nbsp;// 具体的处理逻辑<br />
              &nbsp;&nbsp;return {<br />
              &nbsp;&nbsp;&nbsp;&nbsp;id: Math.random().toString(),<br />
              &nbsp;&nbsp;&nbsp;&nbsp;data: input<br />
              &nbsp;&nbsp;};<br />
              }
            </div>
          </div>
        </div>
      </div>

      <footer>
        <p>TypeScript object 类型详解 &copy; 2023 - 深入理解非原始类型的表示与使用</p>
      </footer>
    </div>

    <script>
      // 演示 object 类型的赋值行为
      function testObjectAssignment() {
          const demo = document.getElementById('typeDetectionDemo');
          demo.innerHTML = '';

          const testValues = [
              { value: {}, type: '空对象', expected: true },
              { value: { name: 'John' }, type: '普通对象', expected: true },
              { value: [1, 2, 3], type: '数组', expected: true },
              { value: new Date(), type: 'Date 对象', expected: true },
              { value: function() {}, type: '函数', expected: true },
              { value: 42, type: '数字', expected: false },
              { value: 'hello', type: '字符串', expected: false },
              { value: true, type: '布尔值', expected: false },
              { value: null, type: 'null', expected: false },
              { value: undefined, type: 'undefined', expected: false }
          ];

          demo.innerHTML += '🧪 测试各种值赋给 object 类型:<br/><br/>';

          testValues.forEach(test => {
              let result;
              try {
                  // 模拟 TypeScript 的类型检查
                  const temp = test.value;
                  if (typeof temp === 'object' && temp !== null) {
                      result = '✅ 允许';
                  } else if (typeof temp === 'function') {
                      result = '✅ 允许';
                  } else {
                      result = '❌ 不允许';
                  }
              } catch (e) {
                  result = '❌ 错误';
              }

              demo.innerHTML += `${test.type}: ${result}<br/>`;
              demo.innerHTML += `   值: ${typeof test.value === 'function' ? 'function() {}' : JSON.stringify(test.value)}<br/><br/>`;
          });
      }

      function testPropertyAccess() {
          const demo = document.getElementById('typeDetectionDemo');
          demo.innerHTML = '';

          demo.innerHTML += '🔍 object 类型的属性访问限制:<br/><br/>';

          const obj = { name: 'John', age: 30 };

          demo.innerHTML += '1. 直接访问 (TypeScript 中会报错):<br/>';
          demo.innerHTML += '   // console.log(obj.name); // ❌ 编译错误<br/>';
          demo.innerHTML += '   // Property name does not exist on type object<br/><br/>';

          demo.innerHTML += '2. 类型断言 (编译通过但可能不安全):<br/>';
          demo.innerHTML += '   console.log((obj as any).name); // ✅ 编译通过<br/>';
          demo.innerHTML += `   实际值: "${obj.name}"<br/><br/>`;

          demo.innerHTML += '3. 类型收窄 (推荐方式):<br/>';
          demo.innerHTML += '   if (name in obj) {<br/>';
          demo.innerHTML += '       console.log(obj.name); // ✅ 安全<br/>';
          demo.innerHTML += '   }<br/>';
          demo.innerHTML += `   实际值: "${'name' in obj ? obj.name : 'undefined'}"<br/><br/>`;

          demo.innerHTML += '4. 使用类型保护函数:<br/>';
          demo.innerHTML += '   function hasName(obj: object): obj is { name: string } {<br/>';
          demo.innerHTML += '       return name in obj && typeof (obj as any).name === string;<br/>';
          demo.innerHTML += '   }<br/>';
          demo.innerHTML += '   if (hasName(obj)) {<br/>';
          demo.innerHTML += '       console.log(obj.name); // ✅ 类型安全<br/>';
          demo.innerHTML += '   }<br/>';
      }

      function clearDemo() {
          document.getElementById('typeDetectionDemo').innerHTML =
              '// 测试各种值是否可以被赋给 object 类型';
      }

      // 页面加载时初始化
      window.addEventListener('load', function() {
          console.log('=== TypeScript object 类型演示 ===');
          console.log('object 类型表示非原始类型的值');
      });

      // 模拟 TypeScript 类型检查的概念
      function demonstrateObjectType() {
          console.log('🔒 object 类型排除了原始类型，提供了比 any 更好的类型安全');
      }
    </script>
  </body>
</html>
