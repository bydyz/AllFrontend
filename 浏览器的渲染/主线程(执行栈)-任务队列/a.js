// JavaScript是一门单线程的语言，因此，JavaScript在同一个时间只能做一件事，单线程意味着，如果在同个时间有多个任务的话，这些任务就需要进行排队，前一个任务执行完，才会执行下一个任务。

// 因为JavaScript的单线程，因此同个时间只能处理同个任务，所有任务都需要排队，前一个任务执行完，才能继续执行下一个任务。但是，如果前一个任务的执行时间很长，比如文件的读取操作或ajax操作，后一个任务就不得不等着，拿ajax来说，当用户向后台获取大量的数据时，不得不等到所有数据都获取完毕才能进行下一步操作，用户只能在那里干等着，严重影响用户体验。因此，JavaScript在设计的时候，就已经考虑到这个问题，主线程可以完全不用等待文件的读取完毕或ajax的加载成功，可以先挂起处于等待中的任务，先运行排在后面的任务，等到文件的读取或ajax有了结果后，再回过头执行挂起的任务，因此，任务就可以分为同步任务和异步任务。

// sync(同步)任务：主线程上排队执行的任务。只有前一个任务执行完毕，才能继续执行下一个任务。（按代码书写的先后顺序执行，上一行代码执行完成才会执行下一行代码）

// async(异步)任务：不进入主线程，而进入任务队列的任务。只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。（跟代码执行时间的长短有关，所需时间短的先执行完）



// JavaScript的异步机制包括以下几个步骤：

// （1）所有同步任务都在主线程上执行，行成一个执行栈
// （2）主线程之外，还存在一个任务队列，只要异步任务有了结果，就会在任务队列中放置一个事件
// （3）一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面还有哪些事件，哪些对应的异步任务，于是异步任务结束等待状态，进入执行栈，开始执行
// （4）主线程不断的重复上面的第三步


// setTimeout是一个延迟函数，可以用它来模拟ajax请求，它是一个异步任务，不会进入主线程，而是进入任务队列，任务队列是一个先进先出的数据结构，第一个setTimeout延迟20ms，第二个setTimeout延迟10ms,所以第二个setTimeout会先执行，第一个setTimeout后执行。fun1()和fun3()位于主线程上，会顺序执行，所以上面的执行顺序是fun1()、fun3()、fun4()、fun2()，依次输出1，3，4，2。

//??? 任务队列是一个先进先出的数据结构

// https://blog.csdn.net/D_lunar/article/details/112215030


function func1() {
  console.log('func1')
}

function func2() {
  console.log('func2')
}

function func3() {
  console.log('func3')
}

function func4() {
  console.log('func4')
}


function mainFunction() {
  func1()

  setTimeout(() => {
    func2()
  }, 3000)

  setTimeout(() => {
    func4()
  }, 2000)

  func3()
}

mainFunction()