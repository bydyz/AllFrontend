<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript属性枚举机制详解</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: #333;
        background: linear-gradient(135deg, #f5f7fa 0%, #e4efe9 100%);
        padding: 20px;
        min-height: 100vh;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }
      header {
        text-align: center;
        margin-bottom: 40px;
        padding: 30px;
        background: white;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      h1 {
        color: #2c3e50;
        margin-bottom: 15px;
      }
      .subtitle {
        color: #7f8c8d;
        font-size: 1.2rem;
        margin-bottom: 20px;
      }
      .card-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 40px;
      }
      .card {
        background: white;
        border-radius: 10px;
        padding: 25px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .card h2 {
        color: #3498db;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid #f0f0f0;
      }
      .code {
        background: #2d3436;
        color: #f5f6fa;
        padding: 15px;
        border-radius: 5px;
        margin: 15px 0;
        overflow-x: auto;
        font-family: "Fira Code", monospace;
        font-size: 0.9rem;
      }
      .interactive-demo {
        background: white;
        border-radius: 10px;
        padding: 25px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        margin-bottom: 40px;
      }
      button {
        background: #3498db;
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        transition: background 0.3s;
        margin: 10px 5px 10px 0;
      }
      button:hover {
        background: #2980b9;
      }
      .result {
        margin-top: 20px;
        padding: 20px;
        background: #edf2f7;
        border-radius: 5px;
        font-family: "Fira Code", monospace;
        white-space: pre-wrap;
      }
      .success {
        color: #27ae60;
      }
      .error {
        color: #e74c3c;
      }
      .highlight {
        background: #fffacd;
        padding: 2px 5px;
        border-radius: 3px;
      }
      .info-box {
        background: #e1f5fe;
        border-left: 4px solid #03a9f4;
        padding: 15px;
        margin: 20px 0;
        border-radius: 0 5px 5px 0;
      }
      footer {
        text-align: center;
        margin-top: 40px;
        color: #7f8c8d;
        padding: 20px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 15px 0;
      }
      th,
      td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid #ddd;
      }
      th {
        background-color: #f2f2f2;
      }
      .property-table {
        width: 100%;
        margin: 20px 0;
      }
      .property-table th,
      .property-table td {
        padding: 12px;
        text-align: center;
        border: 1px solid #ddd;
      }
      .property-table th {
        background-color: #3498db;
        color: white;
      }
      .property-table tr:nth-child(even) {
        background-color: #f9f9f9;
      }
      .explanation {
        margin: 20px 0;
        padding: 20px;
        background: white;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .step-by-step {
        margin: 20px 0;
        padding: 20px;
        background: #fff9e6;
        border-radius: 10px;
        border-left: 4px solid #ffcc00;
      }
      .step {
        margin-bottom: 15px;
        padding-left: 20px;
        position: relative;
      }
      .step:before {
        content: "→";
        position: absolute;
        left: 0;
        color: #ff9900;
        font-weight: bold;
      }
      .method-section {
        margin: 20px 0;
        padding: 20px;
        background: #f8f9fa;
        border-radius: 10px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>JavaScript属性枚举机制详解</h1>
        <p class="subtitle">理解为什么for...in循环不会输出symbol属性和不可枚举属性</p>
      </header>

      <div class="card-container">
        <div class="card">
          <h2>示例代码分析</h2>
          <p>让我们先分析提供的代码：</p>

          <div class="code" style="white-space: pre;">
const obj = {
  visible: 'visible',
  [Symbol('symbol')]: 'symbol value'
};

Object.defineProperty(obj, 'hidden', {
  value: 'hidden value',
  enumerable: false
});

for (const key in obj) {
  console.log(key); // 只输出: 'visible'
}
          </div>

          <p>这个代码创建了一个对象，包含三种类型的属性：</p>
          <ol style="padding-left: 20px; margin: 15px 0">
            <li>可枚举的字符串属性（visible）</li>
            <li>Symbol属性（[Symbol('symbol')]）</li>
            <li>不可枚举的字符串属性（hidden）</li>
          </ol>
        </div>

        <div class="card">
          <h2>for...in循环的行为</h2>
          <p><code>for...in</code>循环在JavaScript中有特定的行为：</p>

          <ul style="padding-left: 20px; margin: 15px 0">
            <li>只遍历对象<strong>自身的可枚举属性</strong></li>
            <li>不遍历Symbol属性</li>
            <li>默认会遍历原型链上的可枚举属性</li>
            <li>遍历顺序不确定（尽管现代浏览器通常按添加顺序）</li>
          </ul>

          <div class="info-box">
            <p><strong>关键点：</strong> <code>for...in</code>只遍历可枚举的字符串键属性，不遍历Symbol属性和不可枚举属性。</p>
          </div>
        </div>

        <div class="card">
          <h2>属性描述符</h2>
          <p>JavaScript中的每个属性都有一个属性描述符，控制属性的行为：</p>

          <ul style="padding-left: 20px; margin: 15px 0">
            <li><code>value</code>: 属性的值</li>
            <li><code>writable</code>: 是否可修改</li>
            <li><code>enumerable</code>: 是否可枚举</li>
            <li><code>configurable</code>: 是否可配置（删除或修改属性特性）</li>
          </ul>

          <div class="code" style="white-space: pre;">
// 查看属性描述符
console.log(Object.getOwnPropertyDescriptor(obj, 'visible'));
// { value: "visible", writable: true, enumerable: true, configurable: true }

console.log(Object.getOwnPropertyDescriptor(obj, 'hidden'));
// { value: "hidden value", writable: false, enumerable: false, configurable: false }
          </div>
        </div>
      </div>

      <div class="explanation">
        <h2>为什么只输出'visible'？</h2>

        <div class="step-by-step">
          <h3>for...in循环的过滤机制:</h3>

          <div class="step">遍历对象的所有属性（包括原型链上的）</div>
          <div class="step">过滤掉不可枚举的属性（enumerable: false）</div>
          <div class="step">过滤掉Symbol属性（ES6 Symbol类型的键）</div>
          <div class="step">只保留可枚举的字符串键属性</div>
        </div>

        <table class="property-table">
          <tr>
            <th>属性名</th>
            <th>类型</th>
            <th>可枚举</th>
            <th>for...in输出</th>
          </tr>
          <tr>
            <td>visible</td>
            <td>字符串</td>
            <td>是</td>
            <td class="success">是</td>
          </tr>
          <tr>
            <td>Symbol('symbol')</td>
            <td>Symbol</td>
            <td>是</td>
            <td class="error">否</td>
          </tr>
          <tr>
            <td>hidden</td>
            <td>字符串</td>
            <td>否</td>
            <td class="error">否</td>
          </tr>
        </table>
      </div>

      <div class="interactive-demo">
        <h2>属性枚举演示</h2>

        <div class="code" style="white-space: pre;">
// 创建演示对象
const demoObj = {
  normal: '普通可枚举属性',
  [Symbol('symbolKey')]: 'Symbol属性值'
};

// 添加不可枚举属性
Object.defineProperty(demoObj, 'hidden', {
  value: '不可枚举属性值',
  enumerable: false
});

// 在原型上添加属性
Object.prototype.protoProperty = '原型链上的属性';
        </div>

        <button onclick="showForInResult()">运行for...in循环</button>
        <button onclick="showAllProperties()">显示所有属性</button>
        <button onclick="showPropertyDescriptors()">显示属性描述符</button>

        <div class="result" id="demoResult">演示结果将显示在这里...</div>
      </div>

      <div class="method-section">
        <h2>获取所有属性类型的方法</h2>

        <div class="code" style="white-space: pre;">
// 1. Object.keys() - 自身可枚举的字符串属性
console.log(Object.keys(obj)); // ['visible']

// 2. Object.getOwnPropertyNames() - 自身所有字符串属性
console.log(Object.getOwnPropertyNames(obj)); // ['visible', 'hidden']

// 3. Object.getOwnPropertySymbols() - 自身所有Symbol属性
console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(symbol)]

// 4. Reflect.ownKeys() - 自身所有属性（包括Symbol）
console.log(Reflect.ownKeys(obj)); // ['visible', 'hidden', Symbol(symbol)]

// 5. for...in - 可枚举的字符串属性（包括原型链）
for (const key in obj) {
  console.log(key); // 'visible' (如果原型链上有属性也会包括)
}
        </div>

        <button onclick="showAllMethods()">运行所有方法</button>

        <div class="result" id="methodsResult">方法比较结果将显示在这里...</div>
      </div>

      <div class="method-section">
        <h2>Symbol属性的特殊性</h2>

        <p>Symbol是ES6引入的新原始数据类型，用作属性键时有以下特点：</p>

        <div class="code" style="white-space: pre;">
// 每个Symbol都是唯一的
const sym1 = Symbol('description');
const sym2 = Symbol('description');
console.log(sym1 === sym2); // false

// 作为属性键
const obj = {
  [sym1]: 'value1',
  [sym2]: 'value2'
};

// Symbol属性不会被常规方法枚举
console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertyNames(obj)); // []
console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(description), Symbol(description)]

// 但可以通过Reflect.ownKeys获取
console.log(Reflect.ownKeys(obj)); // [Symbol(description), Symbol(description)]
        </div>

        <div class="info-box">
          <p><strong>设计目的：</strong> Symbol的主要用途之一是创建"隐藏"属性，这些属性不会意外地被常规代码访问或修改，适合用于元编程和定义内部方法。</p>
        </div>
      </div>

      <div class="method-section">
        <h2>不可枚举属性的用途</h2>

        <p>不可枚举属性常用于以下场景：</p>

        <div class="code" style="white-space: pre;">
// 1. 隐藏内部实现细节
function createApi() {
  const api = {};
  
  // 公共方法
  api.publicMethod = function() {
    return this._internalHelper();
  };
  
  // 内部方法（不可枚举）
  Object.defineProperty(api, '_internalHelper', {
    value: function() { return '内部逻辑'; },
    enumerable: false
  });
  
  return api;
}

// 2. 内置对象的不可枚举属性
console.log(Object.getOwnPropertyDescriptor(Object.prototype, 'toString'));
// { enumerable: false, ... }

// 3. 避免在序列化时包含某些属性
const config = {
  apiUrl: 'https://api.example.com',
  publicKey: 'pk_123456'
};

// 敏感信息设为不可枚举
Object.defineProperty(config, 'secretKey', {
  value: 'sk_abcdef',
  enumerable: false
});

console.log(JSON.stringify(config)); 
// {"apiUrl":"https://api.example.com","publicKey":"pk_123456"}
        </div>
      </div>
    </div>

    <footer>
      <p>© 2023 JavaScript属性枚举机制详解 | 前端开发学习资源</p>
    </footer>

    <script>
      // 创建演示对象
      const demoObj = {
        normal: "普通可枚举属性",
        [Symbol("symbolKey")]: "Symbol属性值",
      };

      // 添加不可枚举属性
      Object.defineProperty(demoObj, "hidden", {
        value: "不可枚举属性值",
        enumerable: false,
      });

      // 在原型上添加属性
      Object.prototype.protoProperty = "原型链上的属性";

      // 显示for...in结果
      function showForInResult() {
        let result = "for...in循环结果:\n";

        for (const key in demoObj) {
          // 检查是否是自身属性
          const isOwn = demoObj.hasOwnProperty(key) ? "自身属性" : "原型属性";
          result += `${key}: ${demoObj[key]} (${isOwn})\n`;
        }

        document.getElementById("demoResult").innerHTML = result;
      }

      // 显示所有属性
      function showAllProperties() {
        let result = "所有属性:\n\n";

        result += "1. Object.keys() (自身可枚举字符串属性):\n";
        result += JSON.stringify(Object.keys(demoObj)) + "\n\n";

        result += "2. Object.getOwnPropertyNames() (自身所有字符串属性):\n";
        result += JSON.stringify(Object.getOwnPropertyNames(demoObj)) + "\n\n";

        result += "3. Object.getOwnPropertySymbols() (自身所有Symbol属性):\n";
        const symbols = Object.getOwnPropertySymbols(demoObj);
        result += symbols.map(sym => sym.toString()) + "\n\n";

        result += "4. Reflect.ownKeys() (自身所有属性):\n";
        result += JSON.stringify(Reflect.ownKeys(demoObj).map(key => (typeof key === "symbol" ? key.toString() : key))) + "\n\n";

        result += "5. 原型链上的属性:\n";
        for (const key in demoObj) {
          if (!demoObj.hasOwnProperty(key)) {
            result += `${key}: ${demoObj[key]}\n`;
          }
        }

        document.getElementById("demoResult").innerHTML = result;
      }

      // 显示属性描述符
      function showPropertyDescriptors() {
        let result = "属性描述符:\n\n";

        // 获取所有自身属性（包括不可枚举和Symbol）
        const allKeys = Reflect.ownKeys(demoObj);

        for (const key of allKeys) {
          const descriptor = Object.getOwnPropertyDescriptor(demoObj, key);
          result += `属性 ${key.toString()}:\n`;
          result += `  可枚举: ${descriptor.enumerable}\n`;
          result += `  可配置: ${descriptor.configurable}\n`;
          result += `  可写: ${descriptor.writable}\n`;
          result += `  值: ${descriptor.value}\n\n`;
        }

        document.getElementById("demoResult").innerHTML = result;
      }

      // 显示所有方法比较
      function showAllMethods() {
        const obj = {
          visible: "visible",
          [Symbol("symbol")]: "symbol value",
        };

        Object.defineProperty(obj, "hidden", {
          value: "hidden value",
          enumerable: false,
        });

        let result = "不同方法获取属性的比较:\n\n";

        result += "1. Object.keys():\n";
        result += JSON.stringify(Object.keys(obj)) + "\n\n";

        result += "2. Object.getOwnPropertyNames():\n";
        result += JSON.stringify(Object.getOwnPropertyNames(obj)) + "\n\n";

        result += "3. Object.getOwnPropertySymbols():\n";
        result += JSON.stringify(Object.getOwnPropertySymbols(obj).map(s => s.toString())) + "\n\n";

        result += "4. Reflect.ownKeys():\n";
        result += JSON.stringify(Reflect.ownKeys(obj).map(k => (typeof k === "symbol" ? k.toString() : k))) + "\n\n";

        result += "5. for...in循环:\n";
        for (const key in obj) {
          result += key + "\n";
        }

        document.getElementById("methodsResult").innerHTML = result;
      }
    </script>
  </body>
</html>
