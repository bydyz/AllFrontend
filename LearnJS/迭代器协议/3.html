<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript迭代器实现详解</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: #333;
        background: linear-gradient(135deg, #f5f7fa 0%, #e4efe9 100%);
        padding: 20px;
        min-height: 100vh;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }
      header {
        text-align: center;
        margin-bottom: 40px;
        padding: 30px;
        background: white;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      h1 {
        color: #2c3e50;
        margin-bottom: 15px;
      }
      .subtitle {
        color: #7f8c8d;
        font-size: 1.2rem;
        margin-bottom: 20px;
      }
      .card-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 40px;
      }
      .card {
        background: white;
        border-radius: 10px;
        padding: 25px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .card h2 {
        color: #3498db;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid #f0f0f0;
      }
      .code {
        background: #2d3436;
        color: #f5f6fa;
        padding: 15px;
        border-radius: 5px;
        margin: 15px 0;
        overflow-x: auto;
        font-family: "Fira Code", monospace;
        font-size: 0.9rem;
      }
      .interactive-demo {
        background: white;
        border-radius: 10px;
        padding: 25px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        margin-bottom: 40px;
      }
      .input-group {
        margin: 15px 0;
      }
      label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
        color: #2c3e50;
      }
      input,
      select {
        width: 100%;
        padding: 12px;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 16px;
        margin-bottom: 10px;
      }
      button {
        background: #3498db;
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        transition: background 0.3s;
        margin: 10px 5px 10px 0;
      }
      button:hover {
        background: #2980b9;
      }
      .result {
        margin-top: 20px;
        padding: 20px;
        background: #edf2f7;
        border-radius: 5px;
        font-family: "Fira Code", monospace;
        white-space: pre-wrap;
      }
      .success {
        color: #27ae60;
      }
      .error {
        color: #e74c3c;
      }
      .highlight {
        background: #fffacd;
        padding: 2px 5px;
        border-radius: 3px;
      }
      .info-box {
        background: #e1f5fe;
        border-left: 4px solid #03a9f4;
        padding: 15px;
        margin: 20px 0;
        border-radius: 0 5px 5px 0;
      }
      footer {
        text-align: center;
        margin-top: 40px;
        color: #7f8c8d;
        padding: 20px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 15px 0;
      }
      th,
      td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid #ddd;
      }
      th {
        background-color: #f2f2f2;
      }
      .comparison-table {
        width: 100%;
        margin: 20px 0;
      }
      .comparison-table th,
      .comparison-table td {
        padding: 12px;
        text-align: center;
        border: 1px solid #ddd;
      }
      .comparison-table th {
        background-color: #3498db;
        color: white;
      }
      .comparison-table tr:nth-child(even) {
        background-color: #f9f9f9;
      }
      .protocol-explanation {
        margin: 20px 0;
        padding: 20px;
        background: white;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .step-by-step {
        margin: 20px 0;
        padding: 20px;
        background: #fff9e6;
        border-radius: 10px;
        border-left: 4px solid #ffcc00;
      }
      .step {
        margin-bottom: 15px;
        padding-left: 20px;
        position: relative;
      }
      .step:before {
        content: "→";
        position: absolute;
        left: 0;
        color: #ff9900;
        font-weight: bold;
      }
      .control-panel {
        display: flex;
        gap: 10px;
        margin: 15px 0;
        flex-wrap: wrap;
      }
      .method-explanation {
        margin: 20px 0;
        padding: 20px;
        background: #f8f9fa;
        border-radius: 10px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>JavaScript迭代器实现详解</h1>
        <p class="subtitle">理解createRangeIterator函数的实现原理</p>
      </header>

      <div class="card-container">
        <div class="card">
          <h2>next()方法</h2>
          <p>next()方法是迭代器协议的核心，它负责：</p>

          <ul style="padding-left: 20px; margin: 15px 0">
            <li>返回序列中的下一个值</li>
            <li>跟踪迭代的当前位置</li>
            <li>指示迭代何时完成</li>
          </ul>

          <div class="code" style="white-space: pre;">
next() {
  if (current <= end) {
    const value = current;
    current += step;
    return { value, done: false };
  }
  return { value: undefined, done: true };
}
          </div>
        </div>

        <div class="card">
          <h2>return()方法</h2>
          <p>return()方法是一个可选方法，用于：</p>

          <ul style="padding-left: 20px; margin: 15px 0">
            <li>在迭代完成前提前终止迭代</li>
            <li>执行清理操作</li>
            <li>返回指定的值</li>
          </ul>

          <div class="code" style="white-space: pre;">
return(value) {
  console.log('迭代提前终止');
  return { value, done: true };
}
          </div>

          <div class="info-box">
            <p><strong>注意：</strong> return()方法不是迭代器协议必需的，但可以实现以便更好地控制迭代过程。</p>
          </div>
        </div>

        <div class="card">
          <h2>[Symbol.iterator]方法</h2>
          <p>[Symbol.iterator]方法使对象成为可迭代对象：</p>

          <ul style="padding-left: 20px; margin: 15px 0">
            <li>允许在for...of循环中使用</li>
            <li>允许使用扩展运算符(...)</li>
            <li>返回迭代器自身</li>
          </ul>

          <div class="code" style="white-space: pre;">[Symbol.iterator]() { return this; }</div>

          <div class="info-box">
            <p><strong>可迭代对象 vs 迭代器：</strong> 可迭代对象具有[Symbol.iterator]方法，迭代器具有next()方法。</p>
          </div>
        </div>
      </div>

      <div class="protocol-explanation">
        <h2>createRangeIterator函数完整解析</h2>

        <div class="code" style="white-space: pre;">
function createRangeIterator(start, end, step = 1) {
  let current = start;
  return {
    next() {
      if (current <= end) {
        const value = current;
        current += step;
        return { value, done: false };
      }
      return { value: undefined, done: true };
    },
    return(value) {
      console.log('迭代提前终止');
      return { value, done: true };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
        </div>

        <div class="step-by-step">
          <h3>函数执行过程:</h3>

          <div class="step">初始化current变量为start值</div>
          <div class="step">返回一个包含三个方法的对象</div>
          <div class="step">next()方法检查是否还有更多值，返回当前值并递增</div>
          <div class="step">return()方法允许提前终止迭代</div>
          <div class="step">[Symbol.iterator]()方法使对象成为可迭代对象</div>
        </div>
      </div>

      <div class="interactive-demo">
        <h2>迭代器演示</h2>

        <div class="input-group">
          <label for="startValue">起始值:</label>
          <input type="number" id="startValue" value="1" />
        </div>

        <div class="input-group">
          <label for="endValue">结束值:</label>
          <input type="number" id="endValue" value="5" />
        </div>

        <div class="input-group">
          <label for="stepValue">步长:</label>
          <input type="number" id="stepValue" value="1" />
        </div>

        <div class="control-panel">
          <button onclick="createIterator()">创建迭代器</button>
          <button onclick="callNext()">调用next()</button>
          <button onclick="callReturn()">调用return()</button>
          <button onclick="useInForOf()">在for...of中使用</button>
          <button onclick="useSpread()">使用扩展运算符</button>
        </div>

        <div class="result" id="iteratorResult">迭代器状态将显示在这里...</div>

        <div class="result" id="iteratorOutput">迭代输出将显示在这里...</div>
      </div>

      <div class="method-explanation">
        <h2>next()方法详解</h2>

        <div class="code" style="white-space: pre;">
// next()方法实现
next() {
  // 检查是否还有更多值
  if (current <= end) {
    // 保存当前值
    const value = current;
    // 递增当前值（步长可能为负数）
    current += step;
    // 返回值和未完成状态
    return { value, done: false };
  }
  // 没有更多值，返回完成状态
  return { value: undefined, done: true };
}
        </div>

        <p>next()方法遵循迭代器协议，每次调用返回一个包含两个属性的对象：</p>
        <ul style="padding-left: 20px; margin: 15px 0">
          <li><code>value</code>: 迭代序列的下一个值，如果没有更多值则为undefined</li>
          <li><code>done</code>: 布尔值，true表示迭代已完成，false表示还有更多值</li>
        </ul>
      </div>

      <div class="method-explanation">
        <h2>return()方法详解</h2>

        <div class="code" style="white-space: pre;">
// return()方法实现
return(value) {
  // 记录提前终止（可选）
  console.log('迭代提前终止');
  // 返回指定的值和完成状态
  return { value, done: true };
}
        </div>

        <p>return()方法是一个可选方法，用于在迭代完成前提前终止迭代：</p>
        <ul style="padding-left: 20px; margin: 15px 0">
          <li>当在for...of循环中使用break、return或throw时自动调用</li>
          <li>可以手动调用以提前终止迭代</li>
          <li>应该返回<code>{ value: value, done: true }</code></li>
          <li>可以执行清理操作（如关闭文件或网络连接）</li>
        </ul>
      </div>

      <div class="method-explanation">
        <h2>[Symbol.iterator]方法详解</h2>

        <div class="code" style="white-space: pre;">
// [Symbol.iterator]方法实现
[Symbol.iterator]() {
  // 返回迭代器自身
  return this;
}
        </div>

        <p>[Symbol.iterator]方法使对象成为可迭代对象：</p>
        <ul style="padding-left: 20px; margin: 15px 0">
          <li>可迭代对象可以在for...of循环中使用</li>
          <li>可迭代对象可以使用扩展运算符(...)</li>
          <li>可迭代对象可以用于解构赋值</li>
          <li>该方法应该返回一个迭代器对象</li>
        </ul>

        <div class="info-box">
          <p><strong>迭代器 vs 可迭代对象：</strong> 迭代器是具有next()方法的对象，可迭代对象是具有[Symbol.iterator]方法的对象。一个对象可以同时是迭代器和可迭代对象。</p>
        </div>
      </div>
    </div>

    <footer>
      <p>© 2023 JavaScript迭代器实现详解 | 前端开发学习资源</p>
    </footer>

    <script>
      let currentIterator = null;
      let iteratorOutput = "";

      // 创建迭代器
      function createIterator() {
        const start = parseInt(document.getElementById("startValue").value);
        const end = parseInt(document.getElementById("endValue").value);
        const step = parseInt(document.getElementById("stepValue").value);

        if (isNaN(start) || isNaN(end) || isNaN(step) || step === 0) {
          document.getElementById("iteratorResult").innerHTML = `<span class="error">请输入有效的起始值、结束值和步长（步长不能为0）</span>`;
          return;
        }

        // 创建迭代器
        currentIterator = createRangeIterator(start, end, step);
        iteratorOutput = "";

        document.getElementById("iteratorResult").innerHTML = `已创建迭代器: 从 ${start} 到 ${end}，步长 ${step}`;
        document.getElementById("iteratorOutput").innerHTML = `迭代输出: 等待调用next()...`;
      }

      // 调用next()方法
      function callNext() {
        if (!currentIterator) {
          document.getElementById("iteratorResult").innerHTML = `<span class="error">请先创建迭代器</span>`;
          return;
        }

        const result = currentIterator.next();

        if (result.done) {
          iteratorOutput += `迭代已完成: { value: ${result.value}, done: ${result.done} }`;
          document.getElementById("iteratorResult").innerHTML = `<span class="success">迭代已完成</span>`;
        } else {
          iteratorOutput += `{ value: ${result.value}, done: ${result.done} }\n`;
          document.getElementById("iteratorResult").innerHTML = `当前状态: { value: ${result.value}, done: ${result.done} }`;
        }

        document.getElementById("iteratorOutput").innerHTML = `迭代输出:\n${iteratorOutput}`;
      }

      // 调用return()方法
      function callReturn() {
        if (!currentIterator) {
          document.getElementById("iteratorResult").innerHTML = `<span class="error">请先创建迭代器</span>`;
          return;
        }

        const returnValue = prompt("请输入return()方法的返回值:", "提前终止");
        const result = currentIterator.return(returnValue);

        iteratorOutput += `调用return(): { value: "${result.value}", done: ${result.done} }\n`;

        document.getElementById("iteratorResult").innerHTML = `迭代已提前终止: { value: "${result.value}", done: ${result.done} }`;
        document.getElementById("iteratorOutput").innerHTML = `迭代输出:\n${iteratorOutput}`;
      }

      // 在for...of中使用
      function useInForOf() {
        if (!currentIterator) {
          document.getElementById("iteratorResult").innerHTML = `<span class="error">请先创建迭代器</span>`;
          return;
        }

        let output = "for...of循环结果:\n";
        try {
          for (const value of currentIterator) {
            output += `${value} `;
            // 模拟提前终止
            if (value > parseInt(document.getElementById("startValue").value) + 2) {
              output += "(提前终止)";
              break;
            }
          }
        } catch (e) {
          output += `错误: ${e.message}`;
        }

        document.getElementById("iteratorOutput").innerHTML = output;
      }

      // 使用扩展运算符
      function useSpread() {
        if (!currentIterator) {
          document.getElementById("iteratorResult").innerHTML = `<span class="error">请先创建迭代器</span>`;
          return;
        }

        try {
          const array = [...currentIterator];
          document.getElementById("iteratorOutput").innerHTML = `扩展运算符结果: [${array.join(", ")}]`;
        } catch (e) {
          document.getElementById("iteratorOutput").innerHTML = `错误: ${e.message}`;
        }
      }

      // createRangeIterator函数实现
      function createRangeIterator(start, end, step = 1) {
        let current = start;
        return {
          next() {
            if ((step > 0 && current <= end) || (step < 0 && current >= end)) {
              const value = current;
              current += step;
              return { value, done: false };
            }
            return { value: undefined, done: true };
          },
          return(value) {
            console.log("迭代提前终止");
            return { value, done: true };
          },
          [Symbol.iterator]() {
            return this;
          },
        };
      }

      // 初始化页面时创建一个默认迭代器
      window.onload = function () {
        createIterator();
      };
    </script>
  </body>
</html>
