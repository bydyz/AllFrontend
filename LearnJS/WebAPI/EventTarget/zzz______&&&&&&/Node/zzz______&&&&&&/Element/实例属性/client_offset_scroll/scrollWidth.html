<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scrollWidth 属性详解</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      body {
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        color: #333;
        line-height: 1.6;
        padding: 20px;
        min-height: 100vh;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        margin-bottom: 40px;
        padding: 30px;
        background: white;
        border-radius: 15px;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
      }

      h1 {
        color: #2c3e50;
        margin-bottom: 15px;
        font-size: 2.5rem;
      }

      .subtitle {
        color: #7f8c8d;
        font-size: 1.3rem;
        max-width: 800px;
        margin: 0 auto;
      }

      .content {
        display: grid;
        grid-template-columns: 100%;
        margin-bottom: 40px;
      }

      .demo-section {
        background: white;
        border-radius: 15px;
        padding: 30px;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        margin-bottom: 40px;
      }

      .explanation-section {
        background: white;
        border-radius: 15px;
        padding: 30px;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
      }

      h2 {
        color: #2c3e50;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 3px solid #1abc9c;
      }

      h3 {
        color: #2c3e50;
        margin: 25px 0 15px 0;
      }

      .demo-container {
        position: relative;
        width: 100%;
        height: 400px;
        border: 2px solid #34495e;
        margin: 25px 0;
        background: #ecf0f1;
        padding: 20px;
        border-radius: 10px;
        overflow: hidden;
      }

      .scroll-element {
        width: 100%;
        height: 100%;
        overflow: auto;
        border: 2px solid #1abc9c;
        border-radius: 8px;
        background: white;
        position: relative;
      }

      .scroll-content {
        min-width: 1200px;
        padding: 20px;
        background: linear-gradient(90deg, #3498db11 0%, #2ecc7111 25%, #e74c3c11 50%, #f39c1211 75%, #9b59b611 100%);
      }

      .content-column {
        display: inline-block;
        width: 280px;
        height: 340px;
        margin: 0 15px;
        padding: 20px;
        border-radius: 8px;
        vertical-align: top;
        border: 2px solid;
        position: relative;
      }

      .column-1 {
        background: #3498db33;
        border-color: #3498db;
      }
      .column-2 {
        background: #2ecc7133;
        border-color: #2ecc71;
      }
      .column-3 {
        background: #e74c3c33;
        border-color: #e74c3c;
      }
      .column-4 {
        background: #f39c1233;
        border-color: #f39c12;
      }
      .column-5 {
        background: #9b59b633;
        border-color: #9b59b6;
      }

      .dimension-visualization {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 5;
      }

      .scrollWidth-highlight {
        position: absolute;
        top: 0;
        bottom: 0;
        background: rgba(26, 188, 156, 0.2);
        border: 2px dashed #1abc9c;
        transition: width 0.3s ease;
      }

      .clientWidth-highlight {
        position: absolute;
        top: 0;
        bottom: 0;
        background: rgba(52, 152, 219, 0.2);
        border: 2px solid #3498db;
        width: 100%;
      }

      .dimension-label {
        position: absolute;
        background: rgba(255, 255, 255, 0.95);
        padding: 6px 12px;
        border-radius: 4px;
        font-size: 0.8rem;
        font-weight: bold;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        white-space: nowrap;
      }

      .scroll-indicator {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(26, 188, 156, 0.9);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 0.9rem;
        font-weight: bold;
        z-index: 10;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      .controls {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin: 20px 0;
      }

      button {
        padding: 12px 15px;
        background: #1abc9c;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.9rem;
        font-weight: 600;
      }

      button:hover {
        background: #16a085;
        transform: translateY(-2px);
      }

      button.secondary {
        background: #3498db;
      }

      button.secondary:hover {
        background: #2980b9;
      }

      .property-display {
        background: #2c3e50;
        color: white;
        padding: 20px;
        border-radius: 10px;
        margin: 20px 0;
      }

      .property-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 10px 0;
        padding: 8px 12px;
        background: #34495e;
        border-radius: 6px;
      }

      .property-name {
        font-weight: bold;
        font-size: 1.1rem;
      }

      .property-value {
        font-family: "Courier New", monospace;
        font-size: 1.2rem;
        color: #f1c40f;
        font-weight: bold;
      }

      .content-controls {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 10px;
        margin: 20px 0;
      }

      .control-group {
        margin: 15px 0;
      }

      .control-label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #2c3e50;
      }

      .range-slider {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: #ddd;
        outline: none;
        -webkit-appearance: none;
      }

      .range-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #1abc9c;
        cursor: pointer;
      }

      .range-value {
        text-align: center;
        font-weight: bold;
        color: #1abc9c;
        margin-top: 5px;
      }

      .width-comparison {
        display: flex;
        justify-content: space-around;
        margin: 20px 0;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
      }

      .width-item {
        text-align: center;
        padding: 10px;
        flex: 1;
      }

      .width-value {
        font-size: 1.2rem;
        font-weight: bold;
        color: #2c3e50;
      }

      .width-label {
        font-size: 0.8rem;
        color: #7f8c8d;
        margin-top: 5px;
      }

      .comparison-table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
        background: white;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .comparison-table th {
        background: #1abc9c;
        color: white;
        padding: 12px 15px;
        text-align: left;
      }

      .comparison-table td {
        padding: 10px 15px;
        border-bottom: 1px solid #ecf0f1;
      }

      .comparison-table tr:nth-child(even) {
        background: #f8f9fa;
      }

      .code-block {
        background: #2c3e50;
        color: #ecf0f1;
        padding: 20px;
        border-radius: 10px;
        font-family: "Courier New", monospace;
        margin: 20px 0;
        overflow-x: auto;
        font-size: 0.9rem;
        line-height: 1.5;
        white-space: pre;
      }

      .special-cases {
        background: #fff9e6;
        padding: 20px;
        border-radius: 10px;
        border-left: 4px solid #f1c40f;
        margin: 20px 0;
      }

      .case-example {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin: 10px 0;
        border: 1px solid #e9ecef;
      }

      .overflow-demo {
        background: #e8f6f3;
        padding: 15px;
        border-radius: 8px;
        margin: 15px 0;
        border: 2px solid #1abc9c;
      }

      @media (max-width: 968px) {
        .content {
          grid-template-columns: 1fr;
        }

        .controls {
          grid-template-columns: 1fr;
        }

        .width-comparison {
          flex-direction: column;
          gap: 10px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>scrollWidth 属性详解</h1>
        <p class="subtitle">深入理解 scrollWidth 的计算方式、应用场景和特殊行为</p>
      </header>

      <div class="content">
        <div class="demo-section">
          <h2>交互演示</h2>
          <p>调整内容宽度，观察 scrollWidth 值的变化</p>

          <div class="demo-container">
            <div class="scroll-element" id="scrollElement">
              <div class="scroll-indicator" id="scrollIndicator">scrollWidth: <span id="scrollWidthValue">1200</span>px</div>
              <div class="dimension-visualization" id="dimensionVisualization">
                <div class="scrollWidth-highlight" id="scrollWidthHighlight"></div>
                <div class="clientWidth-highlight" id="clientWidthHighlight"></div>
              </div>
              <div class="scroll-content" id="scrollContent">
                <div class="content-column column-1">
                  <h3>第一列</h3>
                  <p>scrollWidth = 内容总宽度</p>
                  <p>包括所有可见和不可见内容</p>
                  <div class="overflow-demo">
                    <p>这个区域演示了 scrollWidth 的计算</p>
                    <p>尝试调整内容宽度观察变化</p>
                  </div>
                </div>
                <div class="content-column column-2">
                  <h3>第二列</h3>
                  <p>包含内边距</p>
                  <p>不包含边框和外边距</p>
                  <div style="margin-top: 20px; padding: 15px; background: rgba(255, 255, 255, 0.5); border-radius: 6px">
                    <p>内边距影响 scrollWidth</p>
                    <p>但边框不影响</p>
                  </div>
                </div>
                <div class="content-column column-3">
                  <h3>第三列</h3>
                  <p>伪元素包含在内</p>
                  <p>::before 和 ::after</p>
                  <div style="margin-top: 20px; position: relative">
                    <div style="padding: 10px; background: rgba(255, 255, 255, 0.5); border-radius: 4px">
                      <p>伪元素内容</p>
                      <p>也会计入 scrollWidth</p>
                    </div>
                  </div>
                </div>
                <div class="content-column column-4">
                  <h3>第四列</h3>
                  <p>隐藏内容的影响</p>
                  <p>display: none 不包含</p>
                  <div style="margin-top: 20px">
                    <div class="hidden-content" style="display: none; padding: 10px; background: rgba(255, 255, 255, 0.5)">
                      <p>这个隐藏内容不计入 scrollWidth</p>
                    </div>
                    <div class="visible-content" style="padding: 10px; background: rgba(255, 255, 255, 0.5); border-radius: 4px">
                      <p>可见内容计入 scrollWidth</p>
                    </div>
                  </div>
                </div>
                <div class="content-column column-5">
                  <h3>第五列</h3>
                  <p>overflow 的影响</p>
                  <p>hidden vs visible</p>
                  <div style="margin-top: 20px; padding: 15px; background: rgba(255, 255, 255, 0.5); border-radius: 6px">
                    <p>overflow 不影响 scrollWidth</p>
                    <p>但影响是否需要滚动条</p>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="width-comparison">
            <div class="width-item">
              <div class="width-value" id="scrollWidthDisplay">1200px</div>
              <div class="width-label">scrollWidth</div>
            </div>
            <div class="width-item">
              <div class="width-value" id="clientWidthDisplay">600px</div>
              <div class="width-label">clientWidth</div>
            </div>
            <div class="width-item">
              <div class="width-value" id="offsetWidthDisplay">604px</div>
              <div class="width-label">offsetWidth</div>
            </div>
          </div>

          <div class="content-controls">
            <div class="control-group">
              <label class="control-label">内容总宽度:</label>
              <input type="range" min="800" max="2000" value="1200" class="range-slider" id="contentWidthSlider" />
              <div class="range-value" id="contentWidthValue">1200px</div>
            </div>

            <div class="control-group">
              <label class="control-label">内边距:</label>
              <input type="range" min="10" max="50" value="20" class="range-slider" id="paddingSlider" />
              <div class="range-value" id="paddingValue">20px</div>
            </div>

            <div class="control-group">
              <label class="control-label">列间距:</label>
              <input type="range" min="5" max="30" value="15" class="range-slider" id="marginSlider" />
              <div class="range-value" id="marginValue">15px</div>
            </div>
          </div>

          <div class="controls">
            <button onclick="addNewColumn()">添加新列</button>
            <button onclick="removeColumn()">移除列</button>
            <button onclick="toggleOverflow()">切换overflow</button>
            <button class="secondary" onclick="addPseudoElement()">添加伪元素</button>
            <button class="secondary" onclick="toggleHiddenContent()">切换隐藏内容</button>
            <button onclick="resetAll()">重置所有</button>
          </div>

          <div class="property-display">
            <h3 style="color: white; margin-top: 0">宽度属性对比</h3>
            <div class="property-item">
              <span class="property-name">scrollWidth:</span>
              <span class="property-value" id="scrollWidthVal">1200px</span>
            </div>
            <div class="property-item">
              <span class="property-name">clientWidth:</span>
              <span class="property-value" id="clientWidthVal">600px</span>
            </div>
            <div class="property-item">
              <span class="property-name">offsetWidth:</span>
              <span class="property-value" id="offsetWidthVal">604px</span>
            </div>
            <div class="property-item">
              <span class="property-name">是否需要水平滚动:</span>
              <span class="property-value" id="needsScrollVal">是</span>
            </div>
            <div class="property-item">
              <span class="property-name">溢出宽度:</span>
              <span class="property-value" id="overflowWidthVal">600px</span>
            </div>
          </div>
        </div>

        <div class="explanation-section">
          <h2>scrollWidth 详解</h2>

          <div class="special-cases">
            <h3>📌 scrollWidth 核心定义</h3>
            <p><strong>scrollWidth = 元素内容的总宽度，包括因溢出而不可见的部分</strong></p>
            <p>这是一个只读属性，返回元素内容的完整宽度，不考虑可视区域限制。</p>
          </div>

          <h3>基本计算公式</h3>
          <div class="code-block">
// scrollWidth 包含的内容
element.scrollWidth = 所有内容宽度 + 左右内边距

// 不包含的内容
// - 边框 (border)
// - 外边距 (margin)
// - 滚动条

// 验证计算
const element = document.getElementById('scrollElement');
const contentWidth = Array.from(element.children)
    .reduce((total, child) => total + child.offsetWidth, 0);
const paddingLeft = parseInt(getComputedStyle(element).paddingLeft);
const paddingRight = parseInt(getComputedStyle(element).paddingRight);

console.log('计算的总宽度:', contentWidth + paddingLeft + paddingRight);
console.log('实际的scrollWidth:', element.scrollWidth);
          </div>

          <h3>与其他宽度属性的对比</h3>
          <table class="comparison-table">
            <thead>
              <tr>
                <th>属性</th>
                <th>描述</th>
                <th>包含内容</th>
                <th>不包含内容</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>scrollWidth</strong></td>
                <td>内容总宽度</td>
                <td>所有内容 + 内边距</td>
                <td>边框、外边距、滚动条</td>
              </tr>
              <tr>
                <td>clientWidth</td>
                <td>可视区域宽度</td>
                <td>可视内容 + 内边距</td>
                <td>边框、滚动条、溢出内容</td>
              </tr>
              <tr>
                <td>offsetWidth</td>
                <td>元素整体宽度</td>
                <td>内容 + 内边距 + 边框 + 滚动条</td>
                <td>外边距</td>
              </tr>
              <tr>
                <td>getBoundingClientRect().width</td>
                <td>渲染宽度</td>
                <td>内容 + 内边距 + 边框</td>
                <td>外边距、滚动条</td>
              </tr>
            </tbody>
          </table>

          <h3>特殊情况和注意事项</h3>

          <div class="case-example">
            <h4>情况 1: 伪元素的影响</h4>
            <p>伪元素(::before, ::after)的内容会计入 scrollWidth：</p>
            <div class="code-block">
// CSS 伪元素
.element::before {
    content: "前缀内容";
    display: inline-block;
    width: 100px;
}

.element::after {
    content: "后缀内容";
    display: inline-block;
    width: 100px;
}

// JavaScript 检测
const element = document.querySelector('.element');
console.log('包含伪元素的scrollWidth:', element.scrollWidth);

// 伪元素会增加scrollWidth的值
// 即使它们在视觉上可能不可见
            </div>
          </div>

          <div class="case-example">
            <h4>情况 2: 隐藏内容的影响</h4>
            <p>不同隐藏方式对 scrollWidth 的影响：</p>
            <div class="code-block">
const element = document.getElementById('test');

// display: none 的内容不计入
element.querySelector('.hidden').style.display = 'none';
console.log('隐藏display:none后的scrollWidth:', element.scrollWidth);

// visibility: hidden 的内容会计入
element.querySelector('.invisible').style.visibility = 'hidden';
console.log('隐藏visibility:hidden后的scrollWidth:', element.scrollWidth);

// opacity: 0 的内容会计入
element.querySelector('.transparent').style.opacity = 0;
console.log('透明化后的scrollWidth:', element.scrollWidth);

// 结论：只有完全从文档流中移除的内容才不影响scrollWidth
            </div>
          </div>

          <div class="case-example">
            <h4>情况 3: 内联元素和文本内容</h4>
            <p>对于内联元素，scrollWidth 反映文本内容的实际宽度：</p>
            <div class="code-block">
// 内联元素的scrollWidth
const span = document.createElement('span');
span.textContent = '这是一个很长的文本内容，会自动换行吗？';
document.body.appendChild(span);

console.log('内联元素的scrollWidth:', span.scrollWidth);
console.log('内联元素的offsetWidth:', span.offsetWidth);

// 对于自动换行的文本，scrollWidth表示单行最大宽度
const div = document.createElement('div');
div.style.width = '200px';
div.textContent = '这个文本会在200px宽度内自动换行';
document.body.appendChild(div);

console.log('自动换行元素的scrollWidth:', div.scrollWidth); // 200px
console.log('文本内容的实际宽度:', div.scrollWidth); // 可能小于文本实际宽度
            </div>
          </div>

          <h3>实际应用场景</h3>
          <div class="code-block">
// 应用 1: 检测是否需要水平滚动条
function needsHorizontalScrollbar(element) {
    return element.scrollWidth > element.clientWidth;
}

// 应用 2: 自定义滚动条实现
function createCustomScrollbar(container) {
    const scrollbar = document.createElement('div');
    scrollbar.className = 'custom-scrollbar';
    
    function updateScrollbar() {
        const scrollWidth = container.scrollWidth;
        const clientWidth = container.clientWidth;
        
        if (scrollWidth > clientWidth) {
            // 计算滚动条 thumb 的宽度
            const thumbWidth = (clientWidth / scrollWidth) * clientWidth;
            const thumbPosition = (container.scrollLeft / scrollWidth) * clientWidth;
            
            scrollbar.style.display = 'block';
            scrollbar.querySelector('.thumb').style.width = thumbWidth + 'px';
            scrollbar.querySelector('.thumb').style.left = thumbPosition + 'px';
        } else {
            scrollbar.style.display = 'none';
        }
    }
    
    container.addEventListener('scroll', updateScrollbar);
    window.addEventListener('resize', updateScrollbar);
    updateScrollbar();
    
    return scrollbar;
}

// 应用 3: 响应式表格处理
function setupResponsiveTable(table) {
    const container = table.parentElement;
    
    function checkTableOverflow() {
        const tableWidth = table.scrollWidth;
        const containerWidth = container.clientWidth;
        
        if (tableWidth > containerWidth) {
            // 表格溢出，添加水平滚动提示
            container.classList.add('table-overflow');
            
            // 计算溢出比例
            const overflowRatio = (tableWidth - containerWidth) / tableWidth;
            console.log(`表格溢出比例: ${(overflowRatio * 100).toFixed(1)}%`);
        } else {
            container.classList.remove('table-overflow');
        }
    }
    
    // 监听变化
    const observer = new MutationObserver(checkTableOverflow);
    observer.observe(table, { 
        childList: true, 
        subtree: true, 
        characterData: true 
    });
    
    window.addEventListener('resize', checkTableOverflow);
    checkTableOverflow();
}

// 应用 4: 动态内容加载检测
function setupDynamicContentLoader(container, loadCallback) {
    let isLoading = false;
    
    function checkContentSize() {
        const contentWidth = container.scrollWidth;
        const visibleWidth = container.clientWidth;
        
        // 如果内容宽度突然大幅增加，可能是有新内容加载
        if (contentWidth > visibleWidth * 2 && !isLoading) {
            isLoading = true;
            console.log('检测到大量新内容，优化加载...');
            
            // 可以在这里进行懒加载优化
            optimizeContentLoading(container);
        }
    }
    
    // 使用 MutationObserver 监听内容变化
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'childList' || mutation.type === 'characterData') {
                checkContentSize();
            }
        });
    });
    
    observer.observe(container, {
        childList: true,
        subtree: true,
        characterData: true
    });
}

// 应用 5: 文本省略号检测
function needsEllipsis(element) {
    const scrollWidth = element.scrollWidth;
    const clientWidth = element.clientWidth;
    const offsetWidth = element.offsetWidth;
    
    // 如果内容宽度大于容器宽度，需要显示省略号
    return scrollWidth > clientWidth;
}

// 应用 6: 水平轮播图状态检测
class HorizontalCarousel {
    constructor(container) {
        this.container = container;
        this.items = Array.from(container.children);
        this.updateMetrics();
    }
    
    updateMetrics() {
        this.scrollWidth = this.container.scrollWidth;
        this.clientWidth = this.container.clientWidth;
        this.canScroll = this.scrollWidth > this.clientWidth;
        this.totalItems = this.items.length;
        
        console.log(`轮播图状态: ${this.totalItems}个项目, 可滚动: ${this.canScroll}`);
    }
    
    getVisibleItemCount() {
        const itemWidth = this.items[0].offsetWidth;
        return Math.floor(this.clientWidth / itemWidth);
    }
    
    getTotalPossibleItems() {
        const itemWidth = this.items[0].offsetWidth;
        return Math.floor(this.scrollWidth / itemWidth);
    }
}

// 应用 7: 打印内容检测
function checkPrintContent(element) {
    const naturalWidth = element.scrollWidth;
    const containerWidth = element.clientWidth;
    
    if (naturalWidth > containerWidth) {
        console.warn('内容可能不适合打印，建议调整布局');
        console.log(`内容宽度: ${naturalWidth}px, 容器宽度: ${containerWidth}px`);
        
        // 提供打印优化建议
        suggestPrintOptimizations(naturalWidth, containerWidth);
    }
}
          </div>

          <h3>性能优化和最佳实践</h3>
          <div class="special-cases">
            <p><strong>scrollWidth 会触发重排，使用时需要注意：</strong></p>
            <ul>
              <li>避免在循环中频繁读取 scrollWidth</li>
              <li>使用缓存机制存储计算结果</li>
              <li>在批量操作后一次性读取</li>
              <li>使用 ResizeObserver 监听尺寸变化</li>
            </ul>
            <div class="code-block">
// 不好的做法 - 频繁读取
function badExample() {
    for (let i = 0; i < elements.length; i++) {
        if (elements[i].scrollWidth > threshold) {
            // 每次循环都触发重排
            processElement(elements[i]);
        }
    }
}

// 好的做法 - 批量读取
function goodExample() {
    // 一次性读取所有需要的尺寸
    const measurements = elements.map(el => ({
        element: el,
        scrollWidth: el.scrollWidth,
        clientWidth: el.clientWidth
    }));
    
    // 然后进行处理
    measurements.forEach(({ element, scrollWidth, clientWidth }) => {
        if (scrollWidth > clientWidth) {
            processElement(element);
        }
    });
}

// 使用 ResizeObserver 监听变化
const resizeObserver = new ResizeObserver(entries => {
    entries.forEach(entry => {
        const { scrollWidth, clientWidth } = entry.target;
        if (scrollWidth !== entry.target._cachedScrollWidth) {
            entry.target._cachedScrollWidth = scrollWidth;
            onScrollWidthChange(entry.target, scrollWidth, clientWidth);
        }
    });
});

resizeObserver.observe(element);
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // 获取DOM元素
      const scrollElement = document.getElementById("scrollElement");
      const scrollContent = document.getElementById("scrollContent");
      const scrollIndicator = document.getElementById("scrollIndicator");
      const scrollWidthValue = document.getElementById("scrollWidthValue");
      const dimensionVisualization = document.getElementById("dimensionVisualization");

      // 获取显示元素
      const scrollWidthVal = document.getElementById("scrollWidthVal");
      const clientWidthVal = document.getElementById("clientWidthVal");
      const offsetWidthVal = document.getElementById("offsetWidthVal");
      const needsScrollVal = document.getElementById("needsScrollVal");
      const overflowWidthVal = document.getElementById("overflowWidthVal");
      const scrollWidthDisplay = document.getElementById("scrollWidthDisplay");
      const clientWidthDisplay = document.getElementById("clientWidthDisplay");
      const offsetWidthDisplay = document.getElementById("offsetWidthDisplay");

      // 获取控制元素
      const contentWidthSlider = document.getElementById("contentWidthSlider");
      const paddingSlider = document.getElementById("paddingSlider");
      const marginSlider = document.getElementById("marginSlider");
      const contentWidthValue = document.getElementById("contentWidthValue");
      const paddingValue = document.getElementById("paddingValue");
      const marginValue = document.getElementById("marginValue");

      // 状态变量
      let columnCount = 5;
      let hasPseudoElement = false;
      let hasHiddenContent = false;

      // 更新属性显示
      function updateProperties() {
        const scrollWidth = scrollElement.scrollWidth;
        const clientWidth = scrollElement.clientWidth;
        const offsetWidth = scrollElement.offsetWidth;
        const needsScroll = scrollWidth > clientWidth;
        const overflowWidth = Math.max(0, scrollWidth - clientWidth);

        scrollWidthVal.textContent = scrollWidth + "px";
        clientWidthVal.textContent = clientWidth + "px";
        offsetWidthVal.textContent = offsetWidth + "px";
        needsScrollVal.textContent = needsScroll ? "是" : "否";
        overflowWidthVal.textContent = overflowWidth + "px";

        // 更新指示器
        scrollWidthValue.textContent = scrollWidth;

        // 更新比较显示
        scrollWidthDisplay.textContent = scrollWidth + "px";
        clientWidthDisplay.textContent = clientWidth + "px";
        offsetWidthDisplay.textContent = offsetWidth + "px";

        // 更新可视化
        updateVisualization();
      }

      // 更新可视化
      function updateVisualization() {
        const scrollWidth = scrollElement.scrollWidth;
        const clientWidth = scrollElement.clientWidth;

        const scrollWidthHighlight = document.getElementById("scrollWidthHighlight");
        const clientWidthHighlight = document.getElementById("clientWidthHighlight");

        scrollWidthHighlight.style.width = scrollWidth + "px";

        // 更新标签
        updateDimensionLabels();
      }

      // 更新尺寸标签
      function updateDimensionLabels() {
        // 清除旧标签
        document.querySelectorAll(".dimension-label").forEach(label => label.remove());

        const scrollWidth = scrollElement.scrollWidth;
        const clientWidth = scrollElement.clientWidth;

        // scrollWidth 标签
        const scrollWidthLabel = document.createElement("div");
        scrollWidthLabel.className = "dimension-label";
        scrollWidthLabel.style.top = "50%";
        scrollWidthLabel.style.left = scrollWidth / 2 - 60 + "px";
        scrollWidthLabel.textContent = `scrollWidth: ${scrollWidth}px`;
        dimensionVisualization.appendChild(scrollWidthLabel);

        // clientWidth 标签
        const clientWidthLabel = document.createElement("div");
        clientWidthLabel.className = "dimension-label";
        clientWidthLabel.style.top = "20%";
        clientWidthLabel.style.left = clientWidth / 2 - 60 + "px";
        clientWidthLabel.textContent = `clientWidth: ${clientWidth}px`;
        dimensionVisualization.appendChild(clientWidthLabel);

        // 溢出指示器
        if (scrollWidth > clientWidth) {
          const overflowLabel = document.createElement("div");
          overflowLabel.className = "dimension-label";
          overflowLabel.style.top = "80%";
          overflowLabel.style.left = clientWidth + (scrollWidth - clientWidth) / 2 - 60 + "px";
          overflowLabel.textContent = `溢出: ${scrollWidth - clientWidth}px`;
          overflowLabel.style.background = "rgba(231, 76, 60, 0.9)";
          overflowLabel.style.color = "white";
          dimensionVisualization.appendChild(overflowLabel);
        }
      }

      // 控制函数
      function addNewColumn() {
        columnCount++;
        const newColumn = document.createElement("div");
        newColumn.className = `content-column column-${(columnCount % 5) + 1}`;
        newColumn.innerHTML = `
                <h3>新列 ${columnCount}</h3>
                <p>动态添加的内容</p>
                <p>scrollWidth 增加了</p>
                <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.5); border-radius: 6px;">
                    <p>新列宽度: 280px</p>
                    <p>影响 scrollWidth 计算</p>
                </div>
            `;
        scrollContent.appendChild(newColumn);
        updateProperties();
      }

      function removeColumn() {
        if (columnCount > 1) {
          const lastColumn = scrollContent.lastElementChild;
          if (lastColumn.classList.contains("content-column")) {
            scrollContent.removeChild(lastColumn);
            columnCount--;
            updateProperties();
          }
        }
      }

      function toggleOverflow() {
        const currentOverflow = scrollElement.style.overflowX;
        if (currentOverflow === "hidden") {
          scrollElement.style.overflowX = "auto";
        } else {
          scrollElement.style.overflowX = "hidden";
        }
        updateProperties();
      }

      function addPseudoElement() {
        if (!hasPseudoElement) {
          const style = document.createElement("style");
          style.textContent = `
                    .scroll-content::before {
                        content: "← 伪元素内容 →";
                        display: inline-block;
                        background: rgba(155, 89, 182, 0.3);
                        padding: 10px;
                        margin-right: 20px;
                        border-radius: 4px;
                        border: 1px dashed #9b59b6;
                    }
                `;
          document.head.appendChild(style);
          hasPseudoElement = true;
        }
        updateProperties();
      }

      function toggleHiddenContent() {
        const hiddenContent = scrollContent.querySelector(".hidden-content");
        if (hiddenContent) {
          if (hasHiddenContent) {
            hiddenContent.style.display = "none";
          } else {
            hiddenContent.style.display = "block";
          }
          hasHiddenContent = !hasHiddenContent;
          updateProperties();
        }
      }

      function resetAll() {
        // 重置内容
        scrollContent.innerHTML = `
                <div class="content-column column-1">
                    <h3>第一列</h3>
                    <p>scrollWidth = 内容总宽度</p>
                    <p>包括所有可见和不可见内容</p>
                    <div class="overflow-demo">
                                        <p>这个区域演示了 scrollWidth 的计算</p>
                                        <p>尝试调整内容宽度观察变化</p>
                                    </div>
                                </div>
                                <div class="content-column column-2">
                                    <h3>第二列</h3>
                                    <p>包含内边距</p>
                                    <p>不包含边框和外边距</p>
                                    <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.5); border-radius: 6px;">
                                        <p>内边距影响 scrollWidth</p>
                                        <p>但边框不影响</p>
                                    </div>
                                </div>
                                <div class="content-column column-3">
                                    <h3>第三列</h3>
                                    <p>伪元素包含在内</p>
                                    <p>::before 和 ::after</p>
                                    <div style="margin-top: 20px; position: relative;">
                                        <div style="padding: 10px; background: rgba(255,255,255,0.5); border-radius: 4px;">
                                            <p>伪元素内容</p>
                                            <p>也会计入 scrollWidth</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="content-column column-4">
                                    <h3>第四列</h3>
                                    <p>隐藏内容的影响</p>
                                    <p>display: none 不包含</p>
                                    <div style="margin-top: 20px;">
                                        <div class="hidden-content" style="display: none; padding: 10px; background: rgba(255,255,255,0.5);">
                                            <p>这个隐藏内容不计入 scrollWidth</p>
                                        </div>
                                        <div class="visible-content" style="padding: 10px; background: rgba(255,255,255,0.5); border-radius: 4px;">
                                            <p>可见内容计入 scrollWidth</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="content-column column-5">
                                    <h3>第五列</h3>
                                    <p>overflow 的影响</p>
                                    <p>hidden vs visible</p>
                                    <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.5); border-radius: 6px;">
                                        <p>overflow 不影响 scrollWidth</p>
                                        <p>但影响是否需要滚动条</p>
                                    </div>
                                </div>
                            `;

        // 重置控制
        columnCount = 5;
        hasPseudoElement = false;
        hasHiddenContent = false;
        scrollElement.style.overflowX = "auto";

        // 移除伪元素样式
        document.querySelectorAll("style").forEach(style => {
          if (style.textContent.includes(".scroll-content::before")) {
            style.remove();
          }
        });

        // 重置滑块
        contentWidthSlider.value = 1200;
        paddingSlider.value = 20;
        marginSlider.value = 15;
        contentWidthValue.textContent = "1200px";
        paddingValue.textContent = "20px";
        marginValue.textContent = "15px";

        updateProperties();
      }

      // 事件监听
      contentWidthSlider.addEventListener("input", function () {
        const width = parseInt(this.value);
        scrollContent.style.minWidth = width + "px";
        contentWidthValue.textContent = width + "px";
        updateProperties();
      });

      paddingSlider.addEventListener("input", function () {
        const padding = parseInt(this.value);
        scrollContent.style.padding = padding + "px";
        paddingValue.textContent = padding + "px";
        updateProperties();
      });

      marginSlider.addEventListener("input", function () {
        const margin = parseInt(this.value);
        const columns = scrollContent.querySelectorAll(".content-column");
        columns.forEach(column => {
          column.style.margin = `0 ${margin}px`;
        });
        marginValue.textContent = margin + "px";
        updateProperties();
      });

      // 监听窗口大小变化
      window.addEventListener("resize", updateProperties);

      // 初始化
      updateProperties();

      // 控制台演示
      setTimeout(() => {
        console.log("=== scrollWidth 属性演示 ===");
        console.log("初始 scrollWidth:", scrollElement.scrollWidth);
        console.log("clientWidth:", scrollElement.clientWidth);
        console.log("offsetWidth:", scrollElement.offsetWidth);
        console.log("是否需要水平滚动:", scrollElement.scrollWidth > scrollElement.clientWidth);

        // 演示内容计算
        console.log("\n🔢 内容宽度计算:");
        const columns = scrollContent.querySelectorAll(".content-column");
        let totalContentWidth = 0;
        columns.forEach(column => {
          totalContentWidth += column.offsetWidth;
        });
        const computedStyle = getComputedStyle(scrollContent);
        const paddingLeft = parseInt(computedStyle.paddingLeft);
        const paddingRight = parseInt(computedStyle.paddingRight);

        console.log("列总宽度:", totalContentWidth);
        console.log("内边距:", paddingLeft + paddingRight);
        console.log("计算总宽度:", totalContentWidth + paddingLeft + paddingRight);
        console.log("实际 scrollWidth:", scrollElement.scrollWidth);

        // 检测伪元素影响
        console.log("\n👻 伪元素影响:");
        const beforePseudo = getComputedStyle(scrollContent, "::before");
        console.log("伪元素内容:", beforePseudo.content);
        console.log("伪元素宽度:", beforePseudo.width);
      }, 1000);
    </script>
  </body>
</html>
