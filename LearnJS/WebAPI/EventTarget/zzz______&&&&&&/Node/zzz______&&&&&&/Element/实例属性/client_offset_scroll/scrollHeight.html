<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scrollHeight 属性详解</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      body {
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        color: #333;
        line-height: 1.6;
        padding: 20px;
        min-height: 100vh;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        margin-bottom: 40px;
        padding: 30px;
        background: white;
        border-radius: 15px;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
      }

      h1 {
        color: #2c3e50;
        margin-bottom: 15px;
        font-size: 2.5rem;
      }

      .subtitle {
        color: #7f8c8d;
        font-size: 1.3rem;
        max-width: 800px;
        margin: 0 auto;
      }

      .content {
        display: grid;
        grid-template-columns: 100%;
        margin-bottom: 40px;
      }

      .demo-section {
        background: white;
        border-radius: 15px;
        padding: 30px;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        margin-bottom: 40px;
      }

      .explanation-section {
        background: white;
        border-radius: 15px;
        padding: 30px;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
      }

      h2 {
        color: #2c3e50;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 3px solid #8e44ad;
      }

      h3 {
        color: #2c3e50;
        margin: 25px 0 15px 0;
      }

      .demo-container {
        position: relative;
        width: 100%;
        height: 400px;
        border: 2px solid #34495e;
        margin: 25px 0;
        background: #ecf0f1;
        padding: 20px;
        border-radius: 10px;
        overflow: hidden;
      }

      .scroll-element {
        width: 100%;
        height: 100%;
        overflow: auto;
        border: 2px solid #8e44ad;
        border-radius: 8px;
        background: white;
        position: relative;
      }

      .scroll-content {
        padding: 20px;
        background: linear-gradient(180deg, #3498db11 0%, #2ecc7111 20%, #e74c3c11 40%, #f39c1211 60%, #9b59b611 80%, #1abc9c11 100%);
      }

      .content-section {
        min-height: 180px;
        margin: 20px 0;
        padding: 20px;
        border-radius: 8px;
        border: 2px solid;
        position: relative;
      }

      .section-1 {
        background: #3498db33;
        border-color: #3498db;
      }
      .section-2 {
        background: #2ecc7133;
        border-color: #2ecc71;
      }
      .section-3 {
        background: #e74c3c33;
        border-color: #e74c3c;
      }
      .section-4 {
        background: #f39c1233;
        border-color: #f39c12;
      }
      .section-5 {
        background: #9b59b633;
        border-color: #9b59b6;
      }

      .dimension-visualization {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 5;
      }

      .scrollHeight-highlight {
        position: absolute;
        left: 0;
        right: 0;
        background: rgba(142, 68, 173, 0.2);
        border: 2px dashed #8e44ad;
        transition: height 0.3s ease;
      }

      .clientHeight-highlight {
        position: absolute;
        left: 0;
        right: 0;
        background: rgba(52, 152, 219, 0.2);
        border: 2px solid #3498db;
        height: 100%;
      }

      .dimension-label {
        position: absolute;
        background: rgba(255, 255, 255, 0.95);
        padding: 6px 12px;
        border-radius: 4px;
        font-size: 0.8rem;
        font-weight: bold;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        white-space: nowrap;
      }

      .scroll-indicator {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(142, 68, 173, 0.9);
        color: white;
        padding: 8px 12px;
        border-radius: 20px;
        font-size: 0.9rem;
        font-weight: bold;
        z-index: 10;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      .controls {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin: 20px 0;
      }

      button {
        padding: 12px 15px;
        background: #8e44ad;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.9rem;
        font-weight: 600;
      }

      button:hover {
        background: #7d3c98;
        transform: translateY(-2px);
      }

      button.secondary {
        background: #3498db;
      }

      button.secondary:hover {
        background: #2980b9;
      }

      .property-display {
        background: #2c3e50;
        color: white;
        padding: 20px;
        border-radius: 10px;
        margin: 20px 0;
      }

      .property-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 10px 0;
        padding: 8px 12px;
        background: #34495e;
        border-radius: 6px;
      }

      .property-name {
        font-weight: bold;
        font-size: 1.1rem;
      }

      .property-value {
        font-family: "Courier New", monospace;
        font-size: 1.2rem;
        color: #f1c40f;
        font-weight: bold;
      }

      .content-controls {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 10px;
        margin: 20px 0;
      }

      .control-group {
        margin: 15px 0;
      }

      .control-label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #2c3e50;
      }

      .range-slider {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: #ddd;
        outline: none;
        -webkit-appearance: none;
      }

      .range-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #8e44ad;
        cursor: pointer;
      }

      .range-value {
        text-align: center;
        font-weight: bold;
        color: #8e44ad;
        margin-top: 5px;
      }

      .height-comparison {
        display: flex;
        justify-content: space-around;
        margin: 20px 0;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
      }

      .height-item {
        text-align: center;
        padding: 10px;
        flex: 1;
      }

      .height-value {
        font-size: 1.2rem;
        font-weight: bold;
        color: #2c3e50;
      }

      .height-label {
        font-size: 0.8rem;
        color: #7f8c8d;
        margin-top: 5px;
      }

      .comparison-table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
        background: white;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .comparison-table th {
        background: #8e44ad;
        color: white;
        padding: 12px 15px;
        text-align: left;
      }

      .comparison-table td {
        padding: 10px 15px;
        border-bottom: 1px solid #ecf0f1;
      }

      .comparison-table tr:nth-child(even) {
        background: #f8f9fa;
      }

      .code-block {
        background: #2c3e50;
        color: #ecf0f1;
        padding: 20px;
        border-radius: 10px;
        font-family: "Courier New", monospace;
        margin: 20px 0;
        overflow-x: auto;
        font-size: 0.9rem;
        line-height: 1.5;
        white-space: pre;
      }

      .special-cases {
        background: #fff9e6;
        padding: 20px;
        border-radius: 10px;
        border-left: 4px solid #f1c40f;
        margin: 20px 0;
      }

      .case-example {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin: 10px 0;
        border: 1px solid #e9ecef;
      }

      .auto-expand {
        background: #e8f6f3;
        padding: 15px;
        border-radius: 8px;
        margin: 15px 0;
        border: 2px solid #1abc9c;
      }

      .collapsible-section {
        background: #fef9e7;
        border-left: 4px solid #f1c40f;
        padding: 15px;
        margin: 10px 0;
        border-radius: 0 8px 8px 0;
      }

      .collapsible-content {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
      }

      .collapsible-content.expanded {
        max-height: 500px;
      }

      @media (max-width: 968px) {
        .content {
          grid-template-columns: 1fr;
        }

        .controls {
          grid-template-columns: 1fr;
        }

        .height-comparison {
          flex-direction: column;
          gap: 10px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>scrollHeight 属性详解</h1>
        <p class="subtitle">深入理解 scrollHeight 的计算方式、应用场景和特殊行为</p>
      </header>

      <div class="content">
        <div class="demo-section">
          <h2>交互演示</h2>
          <p>调整内容高度，观察 scrollHeight 值的变化</p>

          <div class="demo-container">
            <div class="scroll-element" id="scrollElement">
              <div class="scroll-indicator" id="scrollIndicator">scrollHeight: <span id="scrollHeightValue">1200</span>px</div>
              <div class="dimension-visualization" id="dimensionVisualization">
                <div class="scrollHeight-highlight" id="scrollHeightHighlight"></div>
                <div class="clientHeight-highlight" id="clientHeightHighlight"></div>
              </div>
              <div class="scroll-content" id="scrollContent">
                <div class="content-section section-1">
                  <h3>第一部分</h3>
                  <p>scrollHeight = 内容总高度</p>
                  <p>包括所有可见和不可见内容</p>
                  <div class="auto-expand">
                    <p>这个区域演示 scrollHeight 的计算</p>
                    <p>尝试调整内容高度观察变化</p>
                  </div>
                </div>
                <div class="content-section section-2">
                  <h3>第二部分</h3>
                  <p>包含上下内边距</p>
                  <p>不包含边框和外边距</p>
                  <div style="margin-top: 15px; padding: 15px; background: rgba(255, 255, 255, 0.5); border-radius: 6px">
                    <p>内边距影响 scrollHeight</p>
                    <p>但边框不影响</p>
                  </div>
                </div>

                <div class="collapsible-section">
                  <h4>可折叠内容区域</h4>
                  <p>点击展开/折叠观察 scrollHeight 变化</p>
                  <button onclick="toggleCollapsible()" style="margin-top: 10px; padding: 8px 16px; background: #f39c12; color: white; border: none; border-radius: 4px; cursor: pointer">切换折叠状态</button>
                  <div class="collapsible-content" id="collapsibleContent">
                    <div style="padding: 15px; background: rgba(255, 255, 255, 0.7); margin-top: 10px; border-radius: 4px">
                      <p>这是可折叠的内容</p>
                      <p>当内容折叠时，scrollHeight 会减少</p>
                      <p>当内容展开时，scrollHeight 会增加</p>
                      <p>这个特性在实现可折叠组件时非常有用</p>
                    </div>
                  </div>
                </div>

                <div class="content-section section-3">
                  <h3>第三部分</h3>
                  <p>伪元素包含在内</p>
                  <p>::before 和 ::after</p>
                  <div style="margin-top: 15px; position: relative; padding: 15px; background: rgba(255, 255, 255, 0.5); border-radius: 6px">
                    <p>伪元素内容</p>
                    <p>也会计入 scrollHeight</p>
                  </div>
                </div>
                <div class="content-section section-4">
                  <h3>第四部分</h3>
                  <p>动态内容的影响</p>
                  <p>实时计算总高度</p>
                  <div style="margin-top: 15px; padding: 15px; background: rgba(255, 255, 255, 0.5); border-radius: 6px">
                    <p>scrollHeight 是实时计算的</p>
                    <p>反映当前的内容总高度</p>
                  </div>
                </div>
                <div class="content-section section-5">
                  <h3>第五部分</h3>
                  <p>overflow 的影响</p>
                  <p>hidden vs visible</p>
                  <div style="margin-top: 15px; padding: 15px; background: rgba(255, 255, 255, 0.5); border-radius: 6px">
                    <p>overflow 不影响 scrollHeight</p>
                    <p>但影响是否需要滚动条</p>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="height-comparison">
            <div class="height-item">
              <div class="height-value" id="scrollHeightDisplay">1200px</div>
              <div class="height-label">scrollHeight</div>
            </div>
            <div class="height-item">
              <div class="height-value" id="clientHeightDisplay">400px</div>
              <div class="height-label">clientHeight</div>
            </div>
            <div class="height-item">
              <div class="height-value" id="offsetHeightDisplay">404px</div>
              <div class="height-label">offsetHeight</div>
            </div>
          </div>

          <div class="content-controls">
            <div class="control-group">
              <label class="control-label">内容区块高度:</label>
              <input type="range" min="100" max="300" value="180" class="range-slider" id="sectionHeightSlider" />
              <div class="range-value" id="sectionHeightValue">180px</div>
            </div>

            <div class="control-group">
              <label class="control-label">内边距:</label>
              <input type="range" min="10" max="50" value="20" class="range-slider" id="paddingSlider" />
              <div class="range-value" id="paddingValue">20px</div>
            </div>

            <div class="control-group">
              <label class="control-label">行高:</label>
              <input type="range" min="1.2" max="2.5" value="1.6" step="0.1" class="range-slider" id="lineHeightSlider" />
              <div class="range-value" id="lineHeightValue">1.6</div>
            </div>
          </div>

          <div class="controls">
            <button onclick="addNewSection()">添加新区块</button>
            <button onclick="removeSection()">移除区块</button>
            <button onclick="toggleOverflow()">切换overflow</button>
            <button class="secondary" onclick="addPseudoElement()">添加伪元素</button>
            <button class="secondary" onclick="toggleAutoExpand()">切换自动扩展</button>
            <button onclick="resetAll()">重置所有</button>
          </div>

          <div class="property-display">
            <h3 style="color: white; margin-top: 0">高度属性对比</h3>
            <div class="property-item">
              <span class="property-name">scrollHeight:</span>
              <span class="property-value" id="scrollHeightVal">1200px</span>
            </div>
            <div class="property-item">
              <span class="property-name">clientHeight:</span>
              <span class="property-value" id="clientHeightVal">400px</span>
            </div>
            <div class="property-item">
              <span class="property-name">offsetHeight:</span>
              <span class="property-value" id="offsetHeightVal">404px</span>
            </div>
            <div class="property-item">
              <span class="property-name">是否需要垂直滚动:</span>
              <span class="property-value" id="needsScrollVal">是</span>
            </div>
            <div class="property-item">
              <span class="property-name">溢出高度:</span>
              <span class="property-value" id="overflowHeightVal">800px</span>
            </div>
          </div>
        </div>

        <div class="explanation-section">
          <h2>scrollHeight 详解</h2>

          <div class="special-cases">
            <h3>📌 scrollHeight 核心定义</h3>
            <p><strong>scrollHeight = 元素内容的总高度，包括因溢出而不可见的部分</strong></p>
            <p>这是一个只读属性，返回元素内容的完整高度，不考虑可视区域限制。</p>
          </div>

          <h3>基本计算公式</h3>
          <div class="code-block">
// scrollHeight 包含的内容
element.scrollHeight = 所有内容高度 + 上下内边距

// 不包含的内容
// - 边框 (border)
// - 外边距 (margin)
// - 滚动条

// 验证计算
const element = document.getElementById('scrollElement');
const contentHeight = Array.from(element.children)
    .reduce((total, child) => total + child.offsetHeight, 0);
const paddingTop = parseInt(getComputedStyle(element).paddingTop);
const paddingBottom = parseInt(getComputedStyle(element).paddingBottom);

console.log('计算的总高度:', contentHeight + paddingTop + paddingBottom);
console.log('实际的scrollHeight:', element.scrollHeight);

// 检测是否需要垂直滚动
const needsVerticalScroll = element.scrollHeight > element.clientHeight;
          </div>

          <h3>与其他高度属性的对比</h3>
          <table class="comparison-table">
            <thead>
              <tr>
                <th>属性</th>
                <th>描述</th>
                <th>包含内容</th>
                <th>不包含内容</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>scrollHeight</strong></td>
                <td>内容总高度</td>
                <td>所有内容 + 内边距</td>
                <td>边框、外边距、滚动条</td>
              </tr>
              <tr>
                <td>clientHeight</td>
                <td>可视区域高度</td>
                <td>可视内容 + 内边距</td>
                <td>边框、滚动条、溢出内容</td>
              </tr>
              <tr>
                <td>offsetHeight</td>
                <td>元素整体高度</td>
                <td>内容 + 内边距 + 边框 + 滚动条</td>
                <td>外边距</td>
              </tr>
              <tr>
                <td>getBoundingClientRect().height</td>
                <td>渲染高度</td>
                <td>内容 + 内边距 + 边框</td>
                <td>外边距、滚动条</td>
              </tr>
            </tbody>
          </table>

          <h3>特殊情况和注意事项</h3>

          <div class="case-example">
            <h4>情况 1: 可折叠内容的影响</h4>
            <p>动态显示/隐藏内容会实时影响 scrollHeight：</p>
            <div class="code-block">
// 可折叠内容对 scrollHeight 的影响
const collapsible = document.getElementById('collapsible');
const content = document.getElementById('collapsibleContent');

function toggleCollapse() {
    if (content.classList.contains('expanded')) {
        // 折叠内容
        content.classList.remove('expanded');
        content.style.maxHeight = '0';
    } else {
        // 展开内容
        content.classList.add('expanded');
        content.style.maxHeight = content.scrollHeight + 'px';
    }
    
    // scrollHeight 会实时更新
    console.log('折叠后的 scrollHeight:', collapsible.scrollHeight);
}

// 使用 scrollHeight 实现平滑动画
function smoothExpand(element) {
    const startHeight = element.clientHeight;
    const targetHeight = element.scrollHeight;
    
    element.style.transition = 'height 0.3s ease';
    element.style.height = startHeight + 'px';
    
    // 强制重排
    element.offsetHeight;
    
    element.style.height = targetHeight + 'px';
}
            </div>
          </div>

          <div class="case-example">
            <h4>情况 2: 文本内容和行高</h4>
            <p>行高和文本换行会影响 scrollHeight：</p>
            <div class="code-block">
// 行高对 scrollHeight 的影响
const textElement = document.getElementById('text');
const lineHeight = parseFloat(getComputedStyle(textElement).lineHeight);
const clientHeight = textElement.clientHeight;

// 计算实际行数
const actualLines = Math.ceil(textElement.scrollHeight / lineHeight);
const visibleLines = Math.floor(clientHeight / lineHeight);

console.log(`总行数: ${actualLines}, 可见行数: ${visibleLines}`);

// 检测文本是否被截断
const isTextTruncated = textElement.scrollHeight > textElement.clientHeight;

// 自动调整文本区域
function autoResizeTextarea(textarea) {
    textarea.style.height = 'auto';
    textarea.style.height = textarea.scrollHeight + 'px';
}
            </div>
          </div>

          <div class="case-example">
            <h4>情况 3: 动态加载内容</h4>
            <p>异步加载内容时 scrollHeight 会更新：</p>
            <div class="code-block">
// 动态内容加载对 scrollHeight 的影响
const container = document.getElementById('container');
let initialHeight = container.scrollHeight;

async function loadMoreContent() {
    // 显示加载指示器
    showLoadingIndicator();
    
    // 模拟异步加载
    const newContent = await fetchMoreData();
    
    // 添加新内容
    container.appendChild(newContent);
    
    // scrollHeight 已更新
    const newHeight = container.scrollHeight;
    console.log(`高度增加: ${newHeight - initialHeight}px`);
    
    // 如果用户接近底部，自动滚动
    const isNearBottom = container.scrollTop + container.clientHeight >= initialHeight - 100;
    if (isNearBottom) {
        container.scrollTop = container.scrollHeight;
    }
    
    initialHeight = newHeight;
    hideLoadingIndicator();
}
            </div>
          </div>

          <h3>实际应用场景</h3>
          <div class="code-block">
// 应用 1: 无限滚动加载
class InfiniteScroll {
    constructor(container, loadCallback) {
        this.container = container;
        this.loadCallback = loadCallback;
        this.isLoading = false;
        this.setup();
    }
    
    setup() {
        this.container.addEventListener('scroll', () => {
            this.checkScrollPosition();
        });
    }
    
    checkScrollPosition() {
        if (this.isLoading) return;
        
        const scrollBottom = this.container.scrollTop + this.container.clientHeight;
        const scrollHeight = this.container.scrollHeight;
        const threshold = 100; // 距离底部100px时触发
        
        if (scrollBottom >= scrollHeight - threshold) {
            this.loadMore();
        }
    }
    
    async loadMore() {
        this.isLoading = true;
        try {
            await this.loadCallback();
        } finally {
            this.isLoading = false;
        }
    }
}

// 应用 2: 自动调整文本区域
function setupAutoResizeTextarea(textarea) {
    function resize() {
        textarea.style.height = 'auto';
        textarea.style.height = textarea.scrollHeight + 'px';
    }
    
    textarea.addEventListener('input', resize);
    textarea.addEventListener('change', resize);
    
    // 初始调整
    resize();
}

// 应用 3: 阅读进度指示器
class ReadingProgress {
    constructor(container, progressBar) {
        this.container = container;
        this.progressBar = progressBar;
        this.setup();
    }
    
    setup() {
        this.container.addEventListener('scroll', () => {
            this.updateProgress();
        });
        this.updateProgress();
    }
    
    updateProgress() {
        const scrollableHeight = this.container.scrollHeight - this.container.clientHeight;
        const progress = scrollableHeight > 0 ? 
            (this.container.scrollTop / scrollableHeight) * 100 : 0;
        
        this.progressBar.style.width = progress + '%';
        this.progressBar.textContent = Math.round(progress) + '%';
    }
}

// 应用 4: 平滑滚动到元素
function smoothScrollToElement(container, targetElement) {
    const elementTop = targetElement.offsetTop;
    const elementHeight = targetElement.offsetHeight;
    const containerHeight = container.clientHeight;
    
    const targetScroll = elementTop - (containerHeight - elementHeight) / 2;
    smoothScrollTo(container, targetScroll);
}

function smoothScrollTo(element, targetPosition, duration = 500) {
    const startPosition = element.scrollTop;
    const distance = targetPosition - startPosition;
    let startTime = null;
    
    function animation(currentTime) {
        if (startTime === null) startTime = currentTime;
        const timeElapsed = currentTime - startTime;
        const progress = Math.min(timeElapsed / duration, 1);
        
        const easeOutCubic = progress => 1 - Math.pow(1 - progress, 3);
        element.scrollTop = startPosition + distance * easeOutCubic(progress);
        
        if (timeElapsed < duration) {
            requestAnimationFrame(animation);
        }
    }
    
    requestAnimationFrame(animation);
}

// 应用 5: 虚拟滚动优化
class VirtualScroll {
    constructor(container, itemHeight, totalItems) {
        this.container = container;
        this.itemHeight = itemHeight;
        this.totalItems = totalItems;
        this.visibleItemCount = Math.ceil(container.clientHeight / itemHeight);
        this.setup();
    }
    
    setup() {
        // 设置容器高度以保持正确的滚动条
        this.container.style.height = (this.totalItems * this.itemHeight) + 'px';
        
        this.container.addEventListener('scroll', () => {
            this.renderVisibleItems();
        });
        
        this.renderVisibleItems();
    }
    
    renderVisibleItems() {
        const scrollTop = this.container.scrollTop;
        const startIndex = Math.floor(scrollTop / this.itemHeight);
        const endIndex = Math.min(startIndex + this.visibleItemCount + 2, this.totalItems);
        
        // 只渲染可见项
        this.renderItems(startIndex, endIndex);
        
        // 更新项的位置
        this.updateItemPositions(startIndex, endIndex);
    }
    
    updateTotalItems(newTotal) {
        this.totalItems = newTotal;
        this.container.style.height = (this.totalItems * this.itemHeight) + 'px';
    }
}

// 应用 6: 内容变化检测
class ContentChangeDetector {
    constructor(container) {
        this.container = container;
        this.lastScrollHeight = container.scrollHeight;
        this.setupObserver();
    }
    
    setupObserver() {
        const observer = new MutationObserver((mutations) => {
            const newScrollHeight = this.container.scrollHeight;
            if (newScrollHeight !== this.lastScrollHeight) {
                this.onContentChange(newScrollHeight, this.lastScrollHeight);
                this.lastScrollHeight = newScrollHeight;
            }
        });
        
        observer.observe(this.container, {
            childList: true,
            subtree: true,
            characterData: true
        });
    }
    
    onContentChange(newHeight, oldHeight) {
        const change = newHeight - oldHeight;
        console.log(`内容高度变化: ${change}px (${oldHeight} → ${newHeight})`);
        
        // 可以在这里触发相关操作，如重新计算布局等
        if (Math.abs(change) > this.container.clientHeight) {
            console.log('检测到大幅内容变化，建议优化');
        }
    }
}

// 应用 7: 分页计算
function calculatePagination(container, itemSelector) {
    const items = container.querySelectorAll(itemSelector);
    const containerHeight = container.clientHeight;
    let currentPage = 1;
    
    function getVisibleItems() {
        const scrollTop = container.scrollTop;
        const scrollBottom = scrollTop + containerHeight;
        
        const visibleItems = Array.from(items).filter(item => {
            const itemTop = item.offsetTop;
            const itemBottom = itemTop + item.offsetHeight;
            return itemBottom > scrollTop && itemTop < scrollBottom;
        });
        
        return visibleItems;
    }
    
    function goToPage(page) {
        const itemsPerPage = Math.floor(containerHeight / items[0].offsetHeight);
        const targetScroll = (page - 1) * itemsPerPage * items[0].offsetHeight;
        smoothScrollTo(container, targetScroll);
    }
    
    function getTotalPages() {
        const totalHeight = container.scrollHeight;
        const pageHeight = containerHeight;
        return Math.ceil(totalHeight / pageHeight);
    }
    
    return {
        getVisibleItems,
        goToPage,
        getTotalPages,
        getCurrentPage: () => currentPage
    };
}
          </div>

          <h3>性能优化和最佳实践</h3>
          <div class="special-cases">
            <p><strong>scrollHeight 会触发重排，使用时需要注意：</strong></p>
            <ul>
              <li>避免在循环或频繁调用的函数中读取 scrollHeight</li>
              <li>使用防抖或节流限制 scroll 事件的处理频率</li>
              <li>缓存计算结果，避免重复读取</li>
              <li>使用 ResizeObserver 监听尺寸变化</li>
            </ul>
            <div class="code-block">
// 性能优化示例
class OptimizedScrollHandler {
    constructor(container) {
        this.container = container;
        this.cachedScrollHeight = null;
        this.setup();
    }
    
    setup() {
        // 使用防抖优化滚动事件
        this.debouncedScrollHandler = this.debounce(() => {
            this.handleScroll();
        }, 50);
        
        this.container.addEventListener('scroll', this.debouncedScrollHandler);
        
        // 监听尺寸变化
        this.resizeObserver = new ResizeObserver(() => {
            this.cachedScrollHeight = null; // 清除缓存
        });
        this.resizeObserver.observe(this.container);
    }
    
    getScrollHeight() {
        // 返回缓存值，避免重排
        if (this.cachedScrollHeight === null) {
            this.cachedScrollHeight = this.container.scrollHeight;
        }
        return this.cachedScrollHeight;
    }
    
    handleScroll() {
        const scrollHeight = this.getScrollHeight();
        const clientHeight = this.container.clientHeight;
        const scrollTop = this.container.scrollTop;
        
        // 使用缓存的值进行计算
        const scrollBottom = scrollTop + clientHeight;
        const scrollPercent = (scrollTop / (scrollHeight - clientHeight)) * 100;
        
        // 处理滚动逻辑...
    }
    
    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
}
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // 获取DOM元素
      const scrollElement = document.getElementById("scrollElement");
      const scrollContent = document.getElementById("scrollContent");
      const scrollIndicator = document.getElementById("scrollIndicator");
      const scrollHeightValue = document.getElementById("scrollHeightValue");
      const dimensionVisualization = document.getElementById("dimensionVisualization");
      const collapsibleContent = document.getElementById("collapsibleContent");

      // 获取显示元素
      const scrollHeightVal = document.getElementById("scrollHeightVal");
      const clientHeightVal = document.getElementById("clientHeightVal");
      const offsetHeightVal = document.getElementById("offsetHeightVal");
      const needsScrollVal = document.getElementById("needsScrollVal");
      const overflowHeightVal = document.getElementById("overflowHeightVal");
      const scrollHeightDisplay = document.getElementById("scrollHeightDisplay");
      const clientHeightDisplay = document.getElementById("clientHeightDisplay");
      const offsetHeightDisplay = document.getElementById("offsetHeightDisplay");

      // 获取控制元素
      const sectionHeightSlider = document.getElementById("sectionHeightSlider");
      const paddingSlider = document.getElementById("paddingSlider");
      const lineHeightSlider = document.getElementById("lineHeightSlider");
      const sectionHeightValue = document.getElementById("sectionHeightValue");
      const paddingValue = document.getElementById("paddingValue");
      const lineHeightValue = document.getElementById("lineHeightValue");

      // 状态变量
      let sectionCount = 5;
      let hasPseudoElement = false;
      let isAutoExpanding = false;

      // 更新属性显示
      function updateProperties() {
        const scrollHeight = scrollElement.scrollHeight;
        const clientHeight = scrollElement.clientHeight;
        const offsetHeight = scrollElement.offsetHeight;
        const needsScroll = scrollHeight > clientHeight;
        const overflowHeight = Math.max(0, scrollHeight - clientHeight);

        scrollHeightVal.textContent = scrollHeight + "px";
        clientHeightVal.textContent = clientHeight + "px";
        offsetHeightVal.textContent = offsetHeight + "px";
        needsScrollVal.textContent = needsScroll ? "是" : "否";
        overflowHeightVal.textContent = overflowHeight + "px";

        // 更新指示器
        scrollHeightValue.textContent = scrollHeight;

        // 更新比较显示
        scrollHeightDisplay.textContent = scrollHeight + "px";
        clientHeightDisplay.textContent = clientHeight + "px";
        offsetHeightDisplay.textContent = offsetHeight + "px";

        // 更新可视化
        updateVisualization();
      }

      // 更新可视化
      function updateVisualization() {
        const scrollHeight = scrollElement.scrollHeight;
        const clientHeight = scrollElement.clientHeight;

        const scrollHeightHighlight = document.getElementById("scrollHeightHighlight");
        const clientHeightHighlight = document.getElementById("clientHeightHighlight");

        scrollHeightHighlight.style.height = scrollHeight + "px";

        // 更新标签
        updateDimensionLabels();
      }

      // 更新尺寸标签
      function updateDimensionLabels() {
        // 清除旧标签
        document.querySelectorAll(".dimension-label").forEach(label => label.remove());

        const scrollHeight = scrollElement.scrollHeight;
        const clientHeight = scrollElement.clientHeight;

        // scrollHeight 标签
        const scrollHeightLabel = document.createElement("div");
        scrollHeightLabel.className = "dimension-label";
        scrollHeightLabel.style.top = scrollHeight / 2 - 20 + "px";
        scrollHeightLabel.style.left = "20px";
        scrollHeightLabel.textContent = `scrollHeight: ${scrollHeight}px`;
        dimensionVisualization.appendChild(scrollHeightLabel);

        // clientHeight 标签
        const clientHeightLabel = document.createElement("div");
        clientHeightLabel.className = "dimension-label";
        clientHeightLabel.style.top = clientHeight / 2 - 20 + "px";
        clientHeightLabel.style.right = "20px";
        clientHeightLabel.textContent = `clientHeight: ${clientHeight}px`;
        dimensionVisualization.appendChild(clientHeightLabel);

        // 溢出指示器
        if (scrollHeight > clientHeight) {
          const overflowLabel = document.createElement("div");
          overflowLabel.className = "dimension-label";
          overflowLabel.style.top = clientHeight + (scrollHeight - clientHeight) / 2 - 20 + "px";
          overflowLabel.style.left = "20px";
          overflowLabel.textContent = `溢出: ${scrollHeight - clientHeight}px`;
          overflowLabel.style.background = "rgba(231, 76, 60, 0.9)";
          overflowLabel.style.color = "white";
          dimensionVisualization.appendChild(overflowLabel);
        }
      }

      // 控制函数
      function addNewSection() {
        sectionCount++;
        const newSection = document.createElement("div");
        newSection.className = `content-section section-${(sectionCount % 5) + 1}`;
        newSection.innerHTML = `
                <h3>新区块 ${sectionCount}</h3>
                <p>动态添加的内容</p>
                <p>scrollHeight 增加了</p>
                <div style="margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.5); border-radius: 6px;">
                    <p>新区块高度: 180px</p>
                    <p>影响 scrollHeight 计算</p>
                </div>
            `;
        scrollContent.appendChild(newSection);
        updateProperties();
      }

      function removeSection() {
        if (sectionCount > 1) {
          const sections = scrollContent.querySelectorAll(".content-section");
          if (sections.length > 1) {
            scrollContent.removeChild(sections[sections.length - 1]);
            sectionCount--;
            updateProperties();
          }
        }
      }

      function toggleOverflow() {
        const currentOverflow = scrollElement.style.overflowY;
        if (currentOverflow === "hidden") {
          scrollElement.style.overflowY = "auto";
        } else {
          scrollElement.style.overflowY = "hidden";
        }
        updateProperties();
      }

      function toggleCollapsible() {
        collapsibleContent.classList.toggle("expanded");
        updateProperties();
      }

      function addPseudoElement() {
        if (!hasPseudoElement) {
          const style = document.createElement("style");
          style.textContent = `
                    .scroll-content::before {
                        content: "↑ 顶部伪元素 ↑";
                        display: block;
                        background: rgba(155, 89, 182, 0.3);
                        padding: 15px;
                        margin-bottom: 20px;
                        border-radius: 8px;
                        border: 1px dashed #9b59b6;
                        text-align: center;
                        font-weight: bold;
                    }
                    .scroll-content::after {
                        content: "↓ 底部伪元素 ↓";
                        display: block;
                        background: rgba(155, 89, 182, 0.3);
                        padding: 15px;
                        margin-top: 20px;
                        border-radius: 8px;
                        border: 1px dashed #9b59b6;
                        text-align: center;
                        font-weight: bold;
                    }
                `;
          document.head.appendChild(style);
          hasPseudoElement = true;
        }
        updateProperties();
      }

      function toggleAutoExpand() {
        const sections = scrollContent.querySelectorAll(".content-section");
        sections.forEach(section => {
          if (isAutoExpanding) {
            section.style.minHeight = "180px";
          } else {
            section.style.minHeight = "auto";
            section.style.height = "auto";
          }
        });
        isAutoExpanding = !isAutoExpanding;
        updateProperties();
      }

      function resetAll() {
        // 重置内容
        scrollContent.innerHTML = `
                <div class="content-section section-1">
                    <h3>第一部分</h3>
                    <p>scrollHeight = 内容总高度</p>
                    <p>包括所有可见和不可见内容</p>
                    <div class="auto-expand">
                        <p>这个区域演示 scrollHeight 的计算</p>
                        <p>尝试调整内容高度观察变化</p>
                    </div>
                </div>
                <div class="content-section section-2">
                    <h3>第二部分</h3>
                    <p>包含上下内边距</p>
                    <p>不包含边框和外边距</p>
                    <div style="margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.5); border-radius: 6px;">
                        <p>内边距影响 scrollHeight</p>
                        <p>但边框不影响</p>
                    </div>
                </div>
                
                <div class="collapsible-section">
                    <h4>可折叠内容区域</h4>
                    <p>点击展开/折叠观察 scrollHeight 变化</p>
                    <button onclick="toggleCollapsible()" style="margin-top: 10px; padding: 8px 16px; background: #f39c12; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        切换折叠状态
                    </button>
                    <div class="collapsible-content" id="collapsibleContent">
                        <div style="padding: 15px; background: rgba(255,255,255,0.7); margin-top: 10px; border-radius: 4px;">
                            <p>这是可折叠的内容</p>
                            <p>当内容折叠时，scrollHeight 会减少</p>
                            <p>当内容展开时，scrollHeight 会增加</p>
                            <p>这个特性在实现可折叠组件时非常有用</p>
                        </div>
                    </div>
                </div>
                
                <div class="content-section section-3">
                    <h3>第三部分</h3>
                    <p>伪元素包含在内</p>
                    <p>::before 和 ::after</p>
                    <div style="margin-top: 15px; position: relative; padding: 15px; background: rgba(255,255,255,0.5); border-radius: 6px;">
                        <p>伪元素内容</p>
                        <p>也会计入 scrollHeight</p>
                    </div>
                </div>
                <div class="content-section section-4">
                    <h3>第四部分</h3>
                    <p>动态内容的影响</p>
                    <p>实时计算总高度</p>
                    <div style="margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.5); border-radius: 6px;">
                        <p>scrollHeight 是实时计算的</p>
                        <p>反映当前的内容总高度</p>
                    </div>
                </div>
                <div class="content-section section-5">
                    <h3>第五部分</h3>
                    <p>overflow 的影响</p>
                    <p>hidden vs visible</p>
                    <div style="margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.5); border-radius: 6px;">
                        <p>overflow 不影响 scrollHeight</p>
                        <p>但影响是否需要滚动条</p>
                    </div>
                </div>
            `;

        // 重新获取可折叠内容元素
        collapsibleContent = document.getElementById("collapsibleContent");

        // 重置控制
        sectionCount = 5;
        hasPseudoElement = false;
        isAutoExpanding = false;
        scrollElement.style.overflowY = "auto";

        // 移除伪元素样式
        document.querySelectorAll("style").forEach(style => {
          if (style.textContent.includes(".scroll-content::")) {
            style.remove();
          }
        });

        // 重置滑块
        sectionHeightSlider.value = 180;
        paddingSlider.value = 20;
        lineHeightSlider.value = 1.6;
        sectionHeightValue.textContent = "180px";
        paddingValue.textContent = "20px";
        lineHeightValue.textContent = "1.6";

        updateProperties();
      }

      // 事件监听
      sectionHeightSlider.addEventListener("input", function () {
        const height = parseInt(this.value);
        const sections = scrollContent.querySelectorAll(".content-section");
        sections.forEach(section => {
          section.style.minHeight = height + "px";
        });
        sectionHeightValue.textContent = height + "px";
        updateProperties();
      });

      paddingSlider.addEventListener("input", function () {
        const padding = parseInt(this.value);
        scrollContent.style.padding = padding + "px";
        paddingValue.textContent = padding + "px";
        updateProperties();
      });

      lineHeightSlider.addEventListener("input", function () {
        const lineHeight = parseFloat(this.value);
        scrollContent.style.lineHeight = lineHeight;
        lineHeightValue.textContent = lineHeight;
        updateProperties();
      });

      // 监听窗口大小变化
      window.addEventListener("resize", updateProperties);

      // 初始化
      updateProperties();

      // 控制台演示
      setTimeout(() => {
        console.log("=== scrollHeight 属性演示 ===");
        console.log("初始 scrollHeight:", scrollElement.scrollHeight);
        console.log("clientHeight:", scrollElement.clientHeight);
        console.log("offsetHeight:", scrollElement.offsetHeight);
        console.log("是否需要垂直滚动:", scrollElement.scrollHeight > scrollElement.clientHeight);

        // 演示内容计算
        console.log("\n🔢 内容高度计算:");
        const sections = scrollContent.querySelectorAll(".content-section, .collapsible-section");
        let totalContentHeight = 0;
        sections.forEach(section => {
          totalContentHeight += section.offsetHeight;
        });
        const computedStyle = getComputedStyle(scrollContent);
        const paddingTop = parseInt(computedStyle.paddingTop);
        const paddingBottom = parseInt(computedStyle.paddingBottom);

        console.log("区块总高度:", totalContentHeight);
        console.log("内边距:", paddingTop + paddingBottom);
        console.log("计算总高度:", totalContentHeight + paddingTop + paddingBottom);
        console.log("实际 scrollHeight:", scrollElement.scrollHeight);

        // 演示可折叠内容的影响
        console.log("\n📦 可折叠内容影响:");
        console.log("折叠状态 scrollHeight:", scrollElement.scrollHeight);
        collapsibleContent.classList.add("expanded");
        setTimeout(() => {
          console.log("展开状态 scrollHeight:", scrollElement.scrollHeight);
          collapsibleContent.classList.remove("expanded");
        }, 1000);
      }, 1000);
    </script>
  </body>
</html>
