<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>offsetTop 属性详解</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      body {
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        color: #333;
        line-height: 1.6;
        padding: 20px;
        min-height: 100vh;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        margin-bottom: 40px;
        padding: 30px;
        background: white;
        border-radius: 15px;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
      }

      h1 {
        color: #2c3e50;
        margin-bottom: 15px;
        font-size: 2.5rem;
      }

      .subtitle {
        color: #7f8c8d;
        font-size: 1.3rem;
        max-width: 800px;
        margin: 0 auto;
      }

      .content {
        display: grid;
        grid-template-columns: 100%;
        margin-bottom: 40px;
      }

      .demo-section {
        background: white;
        border-radius: 15px;
        padding: 30px;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        margin-bottom: 40px;
      }

      .explanation-section {
        background: white;
        border-radius: 15px;
        padding: 30px;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
      }

      h2 {
        color: #2c3e50;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 3px solid #e74c3c;
      }

      h3 {
        color: #2c3e50;
        margin: 25px 0 15px 0;
      }

      .demo-container {
        position: relative;
        width: 100%;
        height: 500px;
        border: 2px solid #34495e;
        margin: 25px 0;
        background: #ecf0f1;
        padding: 30px;
        border-radius: 10px;
        overflow: hidden;
      }

      .hierarchy-container {
        position: relative;
        width: 100%;
        height: 100%;
        border: 2px solid #bdc3c7;
        border-radius: 8px;
        background: white;
        padding: 20px;
      }

      .level-1 {
        position: relative;
        width: 90%;
        height: 400px;
        margin: 0 auto;
        padding: 25px;
        border: 3px solid #3498db;
        background: #3498db11;
        border-radius: 8px;
      }

      .level-2 {
        position: relative;
        width: 80%;
        height: 300px;
        margin: 20px auto;
        padding: 20px;
        border: 3px solid #2ecc71;
        background: #2ecc7111;
        border-radius: 8px;
      }

      .level-3 {
        position: relative;
        width: 70%;
        height: 200px;
        margin: 20px auto;
        padding: 20px;
        border: 3px solid #e74c3c;
        background: #e74c3c11;
        border-radius: 8px;
      }

      .target-element {
        position: absolute;
        width: 120px;
        height: 80px;
        padding: 15px;
        background: #f39c12;
        border: 2px solid #d35400;
        border-radius: 6px;
        color: white;
        font-weight: bold;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: move;
        transition: all 0.3s ease;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      .offset-line {
        position: absolute;
        background: #e74c3c;
        pointer-events: none;
        z-index: 10;
      }

      .offset-line.horizontal {
        height: 2px;
        left: 0;
        right: 0;
      }

      .offset-line.vertical {
        width: 2px;
        top: 0;
        bottom: 0;
      }

      .offset-label {
        position: absolute;
        background: #e74c3c;
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.8rem;
        font-weight: bold;
        pointer-events: none;
        z-index: 11;
      }

      .position-marker {
        position: absolute;
        width: 8px;
        height: 8px;
        background: #e74c3c;
        border-radius: 50%;
        pointer-events: none;
        z-index: 12;
      }

      .controls {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin: 20px 0;
      }

      button {
        padding: 12px 15px;
        background: #e74c3c;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.9rem;
        font-weight: 600;
      }

      button:hover {
        background: #c0392b;
        transform: translateY(-2px);
      }

      button.secondary {
        background: #3498db;
      }

      button.secondary:hover {
        background: #2980b9;
      }

      .property-display {
        background: #2c3e50;
        color: white;
        padding: 20px;
        border-radius: 10px;
        margin: 20px 0;
      }

      .property-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 10px 0;
        padding: 8px 12px;
        background: #34495e;
        border-radius: 6px;
      }

      .property-name {
        font-weight: bold;
        font-size: 1.1rem;
      }

      .property-value {
        font-family: "Courier New", monospace;
        font-size: 1.2rem;
        color: #f1c40f;
        font-weight: bold;
      }

      .position-controls {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 10px;
        margin: 20px 0;
      }

      .control-group {
        margin: 15px 0;
      }

      .control-label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #2c3e50;
      }

      .range-slider {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: #ddd;
        outline: none;
        -webkit-appearance: none;
      }

      .range-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #e74c3c;
        cursor: pointer;
      }

      .range-value {
        text-align: center;
        font-weight: bold;
        color: #e74c3c;
        margin-top: 5px;
      }

      .comparison-table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
        background: white;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .comparison-table th {
        background: #e74c3c;
        color: white;
        padding: 12px 15px;
        text-align: left;
      }

      .comparison-table td {
        padding: 10px 15px;
        border-bottom: 1px solid #ecf0f1;
      }

      .comparison-table tr:nth-child(even) {
        background: #f8f9fa;
      }

      .code-block {
        background: #2c3e50;
        color: #ecf0f1;
        padding: 20px;
        border-radius: 10px;
        font-family: "Courier New", monospace;
        margin: 20px 0;
        overflow-x: auto;
        font-size: 0.9rem;
        line-height: 1.5;
        white-space: pre;
      }

      .special-cases {
        background: #fff9e6;
        padding: 20px;
        border-radius: 10px;
        border-left: 4px solid #f1c40f;
        margin: 20px 0;
      }

      .case-example {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin: 10px 0;
        border: 1px solid #e9ecef;
      }

      .offsetParent-demo {
        background: #e8f6f3;
        padding: 15px;
        border-radius: 8px;
        margin: 15px 0;
        border: 2px solid #1abc9c;
      }

      @media (max-width: 968px) {
        .content {
          grid-template-columns: 1fr;
        }

        .controls {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>offsetTop 属性详解</h1>
        <p class="subtitle">深入理解 offsetTop 的工作原理、offsetParent 特性和实际应用</p>
      </header>

      <div class="content">
        <div class="demo-section">
          <h2>交互演示</h2>
          <p>移动目标元素，观察 offsetTop 值相对于不同 offsetParent 的变化</p>

          <div class="demo-container">
            <div class="hierarchy-container">
              <div class="level-1" id="level1">
                <div class="level-2" id="level2">
                  <div class="level-3" id="level3">
                    <div class="target-element" id="targetElement">目标元素</div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="position-controls">
            <div class="control-group">
              <label class="control-label">目标元素垂直位置:</label>
              <input type="range" min="0" max="120" value="60" class="range-slider" id="verticalSlider" />
              <div class="range-value" id="verticalValue">60px</div>
            </div>

            <div class="control-group">
              <label class="control-label">目标元素水平位置:</label>
              <input type="range" min="0" max="200" value="100" class="range-slider" id="horizontalSlider" />
              <div class="range-value" id="horizontalValue">100px</div>
            </div>
          </div>

          <div class="controls">
            <button onclick="moveToTop()">移动到顶部</button>
            <button onclick="moveToCenter()">移动到中心</button>
            <button onclick="moveToBottom()">移动到底部</button>
            <button class="secondary" onclick="changeOffsetParent('level3')">相对于 Level-3</button>
            <button class="secondary" onclick="changeOffsetParent('level2')">相对于 Level-2</button>
            <button class="secondary" onclick="changeOffsetParent('level1')">相对于 Level-1</button>
          </div>

          <div class="property-display">
            <h3 style="color: white; margin-top: 0">定位属性值</h3>
            <div class="property-item">
              <span class="property-name">offsetTop:</span>
              <span class="property-value" id="offsetTopVal">0px</span>
            </div>
            <div class="property-item">
              <span class="property-name">offsetLeft:</span>
              <span class="property-value" id="offsetLeftVal">0px</span>
            </div>
            <div class="property-item">
              <span class="property-name">offsetParent:</span>
              <span class="property-value" id="offsetParentVal">level-3</span>
            </div>
            <div class="property-item">
              <span class="property-name">offsetWidth:</span>
              <span class="property-value" id="offsetWidthVal">120px</span>
            </div>
            <div class="property-item">
              <span class="property-name">offsetHeight:</span>
              <span class="property-value" id="offsetHeightVal">80px</span>
            </div>
          </div>
        </div>

        <div class="explanation-section">
          <h2>offsetTop 详解</h2>

          <div class="special-cases">
            <h3>📌 offsetTop 核心定义</h3>
            <p><strong>offsetTop = 元素上边界相对于其 offsetParent 上边界的距离</strong></p>
            <p>这是一个只读属性，返回元素相对于最近定位祖先元素的垂直偏移量。</p>
          </div>

          <h3>基本概念</h3>
          <div class="code-block">
// offsetTop 表示元素相对于 offsetParent 的垂直距离
element.offsetTop = 元素顶部 到 offsetParent顶部 的距离

// offsetParent 的确定规则：
// 1. 最近的定位祖先元素 (position ≠ static)
// 2. 如果没有定位祖先，则是最近的 table, td, th, body
// 3. 最终回退到 body 元素

// 示例
const element = document.getElementById('targetElement');

// 获取 offsetTop
console.log('offsetTop:', element.offsetTop);

// 获取 offsetParent
console.log('offsetParent:', element.offsetParent);
console.log('offsetParent tagName:', element.offsetParent.tagName);

// 手动计算验证
const rect = element.getBoundingClientRect();
const parentRect = element.offsetParent.getBoundingClientRect();
const calculatedOffsetTop = rect.top - parentRect.top;

console.log('计算值:', calculatedOffsetTop);
console.log('实际值:', element.offsetTop);
console.log('是否相等:', calculatedOffsetTop === element.offsetTop);
          </div>

          <h3>offsetParent 的确定规则</h3>
          <div class="offsetParent-demo">
            <h4>offsetParent 查找顺序演示</h4>
            <p>尝试点击不同的"相对于"按钮，观察 offsetParent 的变化</p>
            <div id="offsetParentInfo" style="padding: 10px; background: white; border-radius: 4px; font-size: 0.9rem"></div>
          </div>

          <div class="code-block">
// offsetParent 查找算法
function findOffsetParent(element) {
    let current = element.parentElement;
    
    while (current && current !== document.body) {
        const style = getComputedStyle(current);
        
        // 检查是否是定位元素
        if (style.position !== 'static') {
            return current;
        }
        
        // 检查是否是表格相关元素
        if (['TABLE', 'TD', 'TH'].includes(current.tagName)) {
            return current;
        }
        
        current = current.parentElement;
    }
    
    return document.body;
}

// 验证查找结果
const element = document.getElementById('targetElement');
const foundParent = findOffsetParent(element);
const actualParent = element.offsetParent;

console.log('查找到的 offsetParent:', foundParent);
console.log('实际的 offsetParent:', actualParent);
console.log('是否一致:', foundParent === actualParent);
          </div>

          <h3>与其他定位属性的对比</h3>
          <table class="comparison-table">
            <thead>
              <tr>
                <th>属性</th>
                <th>描述</th>
                <th>参照物</th>
                <th>是否包含滚动</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>offsetTop</strong></td>
                <td>相对于 offsetParent 的垂直距离</td>
                <td>offsetParent</td>
                <td>否</td>
              </tr>
              <tr>
                <td>getBoundingClientRect().top</td>
                <td>相对于视口的垂直距离</td>
                <td>视口</td>
                <td>是</td>
              </tr>
              <tr>
                <td>clientTop</td>
                <td>元素上边框宽度</td>
                <td>元素自身</td>
                <td>不适用</td>
              </tr>
              <tr>
                <td>scrollTop</td>
                <td>元素内容垂直滚动距离</td>
                <td>元素自身</td>
                <td>是</td>
              </tr>
            </tbody>
          </table>

          <h3>特殊情况和注意事项</h3>

          <div class="case-example">
            <h4>情况 1: 隐藏元素和 display: none</h4>
            <p>对于隐藏元素，offsetTop 可能返回 0 或不可靠的值：</p>
            <div class="code-block">
// 隐藏元素的情况
const hiddenElement = document.getElementById('hidden');

// display: none 的元素
hiddenElement.style.display = 'none';
console.log('隐藏元素的 offsetTop:', hiddenElement.offsetTop); // 0

// visibility: hidden 的元素
hiddenElement.style.visibility = 'hidden';
console.log('不可见元素的 offsetTop:', hiddenElement.offsetTop); // 正常值

// opacity: 0 的元素
hiddenElement.style.opacity = 0;
console.log('透明元素的 offsetTop:', hiddenElement.offsetTop); // 正常值

// 结论：只有完全从文档流中移除的元素 offsetTop 才为 0
            </div>
          </div>

          <div class="case-example">
            <h4>情况 2: 表格和特殊元素</h4>
            <p>表格相关元素的 offsetParent 行为特殊：</p>
            <div class="code-block">
// 表格中的元素
const tableCell = document.querySelector('td');
const cellContent = tableCell.querySelector('.content');

console.log('表格单元格的 offsetParent:', tableCell.offsetParent);
console.log('单元格内容的 offsetParent:', cellContent.offsetParent);

// 对于表格中的元素，offsetParent 通常是最近的 table, td, th 或 body
// 即使这些元素没有设置定位

// 固定定位元素的特殊情况
const fixedElement = document.querySelector('.fixed');
console.log('固定定位元素的 offsetParent:', fixedElement.offsetParent); // 通常是 null
            </div>
          </div>

          <div class="case-example">
            <h4>情况 3: 变换(transform)的影响</h4>
            <p>CSS transform 不会影响 offsetTop：</p>
            <div class="code-block">
// transform 对 offsetTop 的影响
const element = document.getElementById('target');

// 应用 transform
element.style.transform = 'translateY(100px)';
console.log('应用 transform 后的 offsetTop:', element.offsetTop); // 不变

// transform 改变视觉位置，但不改变布局位置
// offsetTop 仍然反映元素在正常文档流中的位置

// 获取视觉位置需要使用 getBoundingClientRect()
const rect = element.getBoundingClientRect();
console.log('视觉上的顶部位置:', rect.top);
            </div>
          </div>

          <h3>实际应用场景</h3>
          <div class="code-block">
// 应用 1: 元素位置检测和碰撞检测
class PositionTracker {
    constructor(element) {
        this.element = element;
        this.update();
    }
    
    update() {
        this.offsetTop = this.element.offsetTop;
        this.offsetLeft = this.element.offsetLeft;
        this.offsetParent = this.element.offsetParent;
        
        // 计算在文档中的绝对位置
        this.absoluteTop = this.calculateAbsoluteTop();
        this.absoluteLeft = this.calculateAbsoluteLeft();
    }
    
    calculateAbsoluteTop() {
        let top = this.offsetTop;
        let current = this.offsetParent;
        
        while (current && current !== document.body) {
            top += current.offsetTop;
            current = current.offsetParent;
        }
        
        return top;
    }
    
    calculateAbsoluteLeft() {
        let left = this.offsetLeft;
        let current = this.offsetParent;
        
        while (current && current !== document.body) {
            left += current.offsetLeft;
            current = current.offsetParent;
        }
        
        return left;
    }
    
    isCollidingWith(otherElement) {
        const otherTracker = new PositionTracker(otherElement);
        
        const thisRect = {
            top: this.absoluteTop,
            left: this.absoluteLeft,
            right: this.absoluteLeft + this.element.offsetWidth,
            bottom: this.absoluteTop + this.element.offsetHeight
        };
        
        const otherRect = {
            top: otherTracker.absoluteTop,
            left: otherTracker.absoluteLeft,
            right: otherTracker.absoluteLeft + otherElement.offsetWidth,
            bottom: otherTracker.absoluteTop + otherElement.offsetHeight
        };
        
        return !(
            thisRect.right < otherRect.left ||
            thisRect.left > otherRect.right ||
            thisRect.bottom < otherRect.top ||
            thisRect.top > otherRect.bottom
        );
    }
}

// 应用 2: 滚动到元素位置
function scrollToElement(targetElement, container) {
    const offsetTop = targetElement.offsetTop;
    const offsetParent = targetElement.offsetParent;
    
    // 如果目标元素在容器内，滚动到该位置
    if (offsetParent === container || container.contains(targetElement)) {
        container.scrollTop = offsetTop - (container.clientHeight - targetElement.offsetHeight) / 2;
    } else {
        // 计算在文档中的绝对位置
        const absoluteTop = calculateAbsoluteTop(targetElement);
        window.scrollTo({
            top: absoluteTop - window.innerHeight / 2,
            behavior: 'smooth'
        });
    }
}

function calculateAbsoluteTop(element) {
    let top = element.offsetTop;
    let current = element.offsetParent;
    
    while (current && current !== document.body) {
        top += current.offsetTop;
        current = current.offsetParent;
    }
    
    return top;
}

// 应用 3: 拖拽定位系统
class DragPositioning {
    constructor(draggableElement, container) {
        this.element = draggableElement;
        this.container = container;
        this.isDragging = false;
        this.setup();
    }
    
    setup() {
        this.element.addEventListener('mousedown', (e) => {
            this.startDrag(e);
        });
        
        document.addEventListener('mousemove', (e) => {
            if (this.isDragging) {
                this.drag(e);
            }
        });
        
        document.addEventListener('mouseup', () => {
            this.stopDrag();
        });
    }
    
    startDrag(e) {
        this.isDragging = true;
        this.dragStartX = e.clientX - this.element.offsetLeft;
        this.dragStartY = e.clientY - this.element.offsetTop;
    }
    
    drag(e) {
        const newLeft = e.clientX - this.dragStartX;
        const newTop = e.clientY - this.dragStartY;
        
        // 限制在容器范围内
        const maxLeft = this.container.offsetWidth - this.element.offsetWidth;
        const maxTop = this.container.offsetHeight - this.element.offsetHeight;
        
        this.element.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
        this.element.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
        
        // 更新位置信息显示
        this.updatePositionInfo();
    }
    
    stopDrag() {
        this.isDragging = false;
    }
    
    updatePositionInfo() {
        console.log('当前位置 - offsetTop:', this.element.offsetTop);
        console.log('当前位置 - offsetLeft:', this.element.offsetLeft);
    }
}

// 应用 4: 响应式布局检测
function setupLayoutDetection() {
    const elements = document.querySelectorAll('.layout-element');
    
    function checkElementPositions() {
        elements.forEach(element => {
            const offsetTop = element.offsetTop;
            const offsetLeft = element.offsetLeft;
            const viewportHeight = window.innerHeight;
            
            // 检测元素是否在首屏
            const isAboveFold = offsetTop < viewportHeight;
            
            // 根据位置应用不同的样式或行为
            if (isAboveFold) {
                element.classList.add('above-fold');
                element.classList.remove('below-fold');
            } else {
                element.classList.add('below-fold');
                element.classList.remove('above-fold');
            }
            
            // 记录位置信息用于分析
            element.dataset.offsetTop = offsetTop;
            element.dataset.offsetLeft = offsetLeft;
        });
    }
    
    // 初始检测
    checkElementPositions();
    
    // 监听滚动和窗口大小变化
    window.addEventListener('scroll', checkElementPositions);
    window.addEventListener('resize', checkElementPositions);
}

// 应用 5: 虚拟列表实现
class VirtualList {
    constructor(container, itemHeight, totalItems, renderItem) {
        this.container = container;
        this.itemHeight = itemHeight;
        this.totalItems = totalItems;
        this.renderItem = renderItem;
        this.visibleItemCount = Math.ceil(container.clientHeight / itemHeight);
        this.setup();
    }
    
    setup() {
        this.container.addEventListener('scroll', () => {
            this.renderVisibleItems();
        });
        
        this.renderVisibleItems();
    }
    
    renderVisibleItems() {
        const scrollTop = this.container.scrollTop;
        const startIndex = Math.floor(scrollTop / this.itemHeight);
        const endIndex = Math.min(startIndex + this.visibleItemCount + 2, this.totalItems);
        
        // 清除现有内容
        this.container.innerHTML = '';
        
        // 设置容器高度以保持正确的滚动条
        this.container.style.height = (this.totalItems * this.itemHeight) + 'px';
        
        // 渲染可见项
        for (let i = startIndex; i <= endIndex && i < this.totalItems; i++) {
            const item = this.renderItem(i);
            item.style.position = 'absolute';
            item.style.top = (i * this.itemHeight) + 'px';
            item.style.height = this.itemHeight + 'px';
            this.container.appendChild(item);
        }
    }
    
    getItemPosition(index) {
        return index * this.itemHeight;
    }
    
    scrollToItem(index) {
        const targetPosition = this.getItemPosition(index);
        this.container.scrollTop = targetPosition;
    }
}
          </div>

          <h3>性能优化和最佳实践</h3>
          <div class="special-cases">
            <p><strong>offsetTop 会触发重排，使用时需要注意：</strong></p>
            <ul>
              <li>避免在循环或频繁调用的函数中读取 offsetTop</li>
              <li>批量读取多个元素的 offsetTop 值</li>
              <li>使用缓存机制存储计算结果</li>
              <li>考虑使用 getBoundingClientRect() 获取多个值</li>
            </ul>
            <div class="code-block">
// 性能优化示例
class OptimizedPositionManager {
    constructor() {
        this.cache = new Map();
        this.setup();
    }
    
    setup() {
        // 使用 ResizeObserver 监听尺寸变化
        this.resizeObserver = new ResizeObserver((entries) => {
            entries.forEach(entry => {
                this.cache.delete(entry.target);
            });
        });
    }
    
    getOffsetTop(element) {
        if (this.cache.has(element)) {
            return this.cache.get(element);
        }
        
        const offsetTop = element.offsetTop;
        this.cache.set(element, offsetTop);
        
        // 开始观察元素变化
        this.resizeObserver.observe(element);
        
        return offsetTop;
    }
    
    batchGetPositions(elements) {
        // 一次性读取多个元素的位置，减少重排次数
        const positions = elements.map(element => ({
            element,
            offsetTop: this.getOffsetTop(element),
            offsetLeft: element.offsetLeft,
            offsetParent: element.offsetParent
        }));
        
        return positions;
    }
    
    // 使用 getBoundingClientRect() 获取多个值
    getComprehensivePosition(element) {
        const rect = element.getBoundingClientRect();
        const offsetTop = element.offsetTop;
        const offsetLeft = element.offsetLeft;
        
        return {
            // offsetTop 相关
            offsetTop,
            absoluteTop: this.calculateAbsoluteTop(element),
            viewportTop: rect.top,
            
            // 其他位置信息
            offsetLeft,
            absoluteLeft: this.calculateAbsoluteLeft(element),
            viewportLeft: rect.left,
            
            // 尺寸信息
            width: element.offsetWidth,
            height: element.offsetHeight,
            clientWidth: element.clientWidth,
            clientHeight: element.clientHeight
        };
    }
}
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // 获取DOM元素
      const targetElement = document.getElementById("targetElement");
      const level1 = document.getElementById("level1");
      const level2 = document.getElementById("level2");
      const level3 = document.getElementById("level3");

      // 获取显示元素
      const offsetTopVal = document.getElementById("offsetTopVal");
      const offsetLeftVal = document.getElementById("offsetLeftVal");
      const offsetParentVal = document.getElementById("offsetParentVal");
      const offsetWidthVal = document.getElementById("offsetWidthVal");
      const offsetHeightVal = document.getElementById("offsetHeightVal");
      const offsetParentInfo = document.getElementById("offsetParentInfo");

      // 获取控制元素
      const verticalSlider = document.getElementById("verticalSlider");
      const horizontalSlider = document.getElementById("horizontalSlider");
      const verticalValue = document.getElementById("verticalValue");
      const horizontalValue = document.getElementById("horizontalValue");

      // 状态变量
      let currentOffsetParent = level3;
      let isDragging = false;
      let dragStartX, dragStartY, originalLeft, originalTop;

      // 更新属性显示
      function updateProperties() {
        const offsetTop = targetElement.offsetTop;
        const offsetLeft = targetElement.offsetLeft;
        const offsetParent = targetElement.offsetParent;
        const offsetWidth = targetElement.offsetWidth;
        const offsetHeight = targetElement.offsetHeight;

        offsetTopVal.textContent = offsetTop + "px";
        offsetLeftVal.textContent = offsetLeft + "px";
        offsetParentVal.textContent = getElementName(offsetParent);
        offsetWidthVal.textContent = offsetWidth + "px";
        offsetHeightVal.textContent = offsetHeight + "px";

        // 更新可视化
        updateVisualization();

        // 更新 offsetParent 信息
        updateOffsetParentInfo();
      }

      // 获取元素名称
      function getElementName(element) {
        if (element === level1) return "level-1";
        if (element === level2) return "level-2";
        if (element === level3) return "level-3";
        if (element === document.body) return "body";
        return element.id || element.tagName.toLowerCase();
      }

      // 更新可视化
      function updateVisualization() {
        // 清除旧的可视化元素
        document.querySelectorAll(".offset-line, .offset-label, .position-marker").forEach(el => el.remove());

        const offsetTop = targetElement.offsetTop;
        const offsetLeft = targetElement.offsetLeft;
        const offsetParent = targetElement.offsetParent;

        // 创建水平偏移线
        const horizontalLine = document.createElement("div");
        horizontalLine.className = "offset-line horizontal";
        horizontalLine.style.top = offsetTop + targetElement.offsetHeight / 2 + "px";
        offsetParent.appendChild(horizontalLine);

        // 创建垂直偏移线
        const verticalLine = document.createElement("div");
        verticalLine.className = "offset-line vertical";
        verticalLine.style.left = offsetLeft + targetElement.offsetWidth / 2 + "px";
        offsetParent.appendChild(verticalLine);

        // 创建 offsetTop 标签
        const topLabel = document.createElement("div");
        topLabel.className = "offset-label";
        topLabel.style.top = offsetTop / 2 + "px";
        topLabel.style.left = "10px";
        topLabel.textContent = `offsetTop: ${offsetTop}px`;
        offsetParent.appendChild(topLabel);

        // 创建 offsetLeft 标签
        const leftLabel = document.createElement("div");
        leftLabel.className = "offset-label";
        leftLabel.style.top = "10px";
        leftLabel.style.left = offsetLeft / 2 + "px";
        leftLabel.textContent = `offsetLeft: ${offsetLeft}px`;
        offsetParent.appendChild(leftLabel);

        // 创建位置标记
        const topMarker = document.createElement("div");
        topMarker.className = "position-marker";
        topMarker.style.top = offsetTop + "px";
        topMarker.style.left = offsetLeft + targetElement.offsetWidth / 2 + "px";
        offsetParent.appendChild(topMarker);

        const leftMarker = document.createElement("div");
        leftMarker.className = "position-marker";
        leftMarker.style.top = offsetTop + targetElement.offsetHeight / 2 + "px";
        leftMarker.style.left = offsetLeft + "px";
        offsetParent.appendChild(leftMarker);
      }

      // 更新 offsetParent 信息
      function updateOffsetParentInfo() {
        const offsetParent = targetElement.offsetParent;
        const parentStyle = getComputedStyle(offsetParent);

        let info = `
                <strong>当前 offsetParent:</strong> ${getElementName(offsetParent)}<br>
                <strong>position 属性:</strong> ${parentStyle.position}<br>
                <strong>offsetTop:</strong> ${offsetParent.offsetTop}px<br>
                <strong>offsetLeft:</strong> ${offsetParent.offsetLeft}px
            `;

        // 显示查找路径
        info += `<br><br><strong>offsetParent 查找路径:</strong><br>`;
        let current = targetElement;
        let path = [];

        while (current && current !== document.body) {
          path.push(getElementName(current));
          current = current.offsetParent;
        }
        path.push("body");

        info += path.join(" → ");

        offsetParentInfo.innerHTML = info;
      }

      // 控制函数
      function moveToTop() {
        targetElement.style.top = "0px";
        targetElement.style.left = "50%";
        targetElement.style.transform = "translateX(-50%)";
        updateProperties();
      }

      function moveToCenter() {
        const parent = currentOffsetParent;
        const centerX = (parent.offsetWidth - targetElement.offsetWidth) / 2;
        const centerY = (parent.offsetHeight - targetElement.offsetHeight) / 2;

        targetElement.style.top = centerY + "px";
        targetElement.style.left = centerX + "px";
        updateProperties();
      }

      function moveToBottom() {
        const parent = currentOffsetParent;
        const bottomY = parent.offsetHeight - targetElement.offsetHeight;

        targetElement.style.top = bottomY + "px";
        targetElement.style.left = "50%";
        targetElement.style.transform = "translateX(-50%)";
        updateProperties();
      }

      function changeOffsetParent(parentId) {
        const newParent = document.getElementById(parentId);

        // 移除目标元素从当前父级
        targetElement.parentElement.removeChild(targetElement);

        // 添加到新的父级
        newParent.appendChild(targetElement);

        // 重置位置到中心
        moveToCenter();

        currentOffsetParent = newParent;
        updateProperties();
      }

      // 拖拽功能
      function setupDragging() {
        targetElement.addEventListener("mousedown", startDrag);
        document.addEventListener("mousemove", drag);
        document.addEventListener("mouseup", stopDrag);
      }

      function startDrag(e) {
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        originalLeft = parseInt(targetElement.style.left) || 0;
        originalTop = parseInt(targetElement.style.top) || 0;

        targetElement.style.cursor = "grabbing";
        e.preventDefault();
      }

      function drag(e) {
        if (!isDragging) return;

        const deltaX = e.clientX - dragStartX;
        const deltaY = e.clientY - dragStartY;

        const newLeft = originalLeft + deltaX;
        const newTop = originalTop + deltaY;

        // 限制在父元素范围内
        const parent = currentOffsetParent;
        const maxLeft = parent.offsetWidth - targetElement.offsetWidth;
        const maxTop = parent.offsetHeight - targetElement.offsetHeight;

        targetElement.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + "px";
        targetElement.style.top = Math.max(0, Math.min(newTop, maxTop)) + "px";

        updateProperties();
      }

      function stopDrag() {
        isDragging = false;
        targetElement.style.cursor = "move";
      }

      // 事件监听
      verticalSlider.addEventListener("input", function () {
        const value = parseInt(this.value);
        targetElement.style.top = value + "px";
        verticalValue.textContent = value + "px";
        updateProperties();
      });

      horizontalSlider.addEventListener("input", function () {
        const value = parseInt(this.value);
        targetElement.style.left = value + "px";
        horizontalValue.textContent = value + "px";
        updateProperties();
      });

      // 初始化拖拽
      setupDragging();

      // 初始化
      updateProperties();

      // 控制台演示
      setTimeout(() => {
        console.log("=== offsetTop 属性演示 ===");
        console.log("初始 offsetTop:", targetElement.offsetTop);
        console.log("offsetParent:", targetElement.offsetParent);
        console.log("offsetParent 的 position:", getComputedStyle(targetElement.offsetParent).position);

        // 演示 offsetParent 查找
        console.log("\n🔍 offsetParent 查找演示:");
        let current = targetElement;
        console.log("查找路径:");
        while (current && current !== document.body) {
          console.log(`${getElementName(current)} → offsetParent: ${getElementName(current.offsetParent)}`);
          current = current.offsetParent;
        }

        // 演示手动计算
        console.log("\n🧮 手动计算验证:");
        const rect = targetElement.getBoundingClientRect();
        const parentRect = targetElement.offsetParent.getBoundingClientRect();
        const calculatedOffsetTop = rect.top - parentRect.top;

        console.log("元素顶部位置:", rect.top);
        console.log("offsetParent 顶部位置:", parentRect.top);
        console.log("计算 offsetTop:", calculatedOffsetTop);
        console.log("实际 offsetTop:", targetElement.offsetTop);
        console.log("是否相等:", calculatedOffsetTop === targetElement.offsetTop);
      }, 1000);
    </script>
  </body>
</html>
