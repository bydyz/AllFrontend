//! 异步函数的执行过程中的暂停是指在遇到异步操作时，异步函数会将该操作委托给异步任务队列（event loop）处理，并立即返回一个 Promise 对象，而不是等待异步操作完成后再继续执行后续代码。这样，主线程可以继续执行其他任务，而不必等待异步操作完成。因此，尽管异步函数的执行过程中会暂停，但不会阻塞主线程，主线程可以继续执行其他任务。

//! 当异步操作完成后，异步任务队列会将相应的回调函数（如 then 或 catch 中的回调函数）推入任务队列中等待执行。当主线程空闲时，事件循环会检查任务队列，如果有任务需要执行，则将其取出并执行。这样，异步操作的完成并不会阻塞主线程，而是在异步任务完成后由事件循环调度执行其回调函数，从而实现了非阻塞的异步执行模式。


const returnPromise = function() {
  return new Promise((resolve, reject) => {
    console.log("函数中要返回的promise")

    resolve("111")
  })
}


const testFunc = async function() {
  console.log("使用returnPromise之前")

  await returnPromise()

  console.log("使用returnPromise之后")
}

console.log("异步函数前")
testFunc()
console.log("异步函数后")





// 在遇到 async 和 await 时，浏览器的渲染进程并不会被阻塞。当遇到 await 关键字时，异步函数会暂停执行，将控制权交回给调用者，这样浏览器可以继续处理其他任务，如用户交互、页面渲染等。异步函数内部的异步操作会被封装成一个 Promise 对象，并被放入任务队列中等待执行。

// 一旦异步操作完成，Promise 对象的状态会发生改变，触发相应的回调函数执行。这些回调函数会被添加到任务队列中，等待事件循环处理。当主线程空闲时，事件循环会检查任务队列，并执行队列中的任务，包括异步操作的回调函数。

// 总的来说，async 和 await 可以让 JavaScript 代码以同步的方式编写异步操作，但在实际执行过程中，仍然是基于事件循环机制的非阻塞异步执行。这样可以确保浏览器的渲染进程不会被长时间阻塞，保持页面的响应性和流畅性。