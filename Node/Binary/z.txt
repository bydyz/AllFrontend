◼ 计算机中所有的内容：文字、数字、图片、音频、视频最终都会使用二进制来表示。

◼ JavaScript可以直接去处理非常直观的数据：比如字符串，我们通常展示给用户的也是这些内容。

◼ 不对啊，JavaScript不是也可以处理图片吗？
   事实上在网页端，图片我们一直是交给浏览器来处理的；
   JavaScript或者HTML，只是负责告诉浏览器一个图片的地址；
   浏览器负责获取这个图片，并且最终讲这个图片渲染出来；

◼ 但是对于服务器来说是不一样的：
   服务器要处理的本地文件类型相对较多;
   比如某一个保存文本的文件并不是使用 utf-8进行编码的，而是用 GBK，那么我们必须读取到他们的二进制数据，再通过GKB转换成对应的文字；
   比如我们需要读取的是一张图片数据（二进制），再通过某些手段对图片数据进行二次的处理（裁剪、格式转换、旋转、添加滤镜），Node中有一个Sharp的库，就是读取图片或者传入图片的Buffer对其再进行处理；
   比如在Node中通过TCP建立长连接，TCP传输的是字节流，我们需要将数据转成字节再进行传入，并且需要知道传输字节的大小（客服端需要根据大小来判断读取多少内容）；


◼ 我们会发现，对于前端开发来说，通常很少会和二进制直接打交道，但是对于服务器端为此做很多的功能，我们必须直接去操作其二进制的数据；

◼ 所以Node为了可以方便开发者完成更多功能，提供给了我们一个类Buffer，并且它是全局的。

◼ 我们前面说过，Buffer中存储的是二进制数据，那么到底是如何存储呢？
   我们可以将Buffer看成是一个存储二进制的数组；
   这个数组中的每一项，可以保存8位二进制： 0000 0000

◼ 为什么是8位呢？
   在计算机中，很少的情况我们会直接操作一位二进制，因为一位二进制存储的数据是非常有限的；
   所以通常会将8位合在一起作为一个单元，这个单元称之为一个字节（byte）；
   也就是说 1byte = 8bit，1kb = 1024byte，1M = 1024kb；
   比如很多编程语言中的int类型是4个字节，long类型时8个字节；
   比如TCP传输的是字节流，在写入和读取时都需要说明字节的个数；
   比如RGB的值分别都是255，所以本质上在计算机中都是用一个字节存储的；






事实上我们创建Buffer时，并不会频繁的向操作系统申请内存，它会默认先申请一个8 * 1024个字节大小的内存，也就是8kb