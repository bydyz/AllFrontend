事实上随着前端的快速发展，目前前端的开发已经变的越来越复杂了：
  比如开发过程中我们需要通过模块化的方式来开发；
  比如也会使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码；
  比如开发过程中，我们还希望实时的监听文件的变化来并且反映到浏览器上，提高开发的效率；
  比如开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化；
  等等….


但是对于很多的前端开发者来说，并不需要思考这些问题，日常的开发中根本就没有面临这些问题：
  这是因为目前前端开发我们通常都会直接使用三大框架来开发：Vue、React、Angular；
  但是事实上，这三大框架的创建过程我们都是借助于脚手架（CLI）的；
  事实上Vue-CLI、create-react-app、Angular-CLI都是基于webpack来帮助我们支持模块化、less、TypeScript、打包优化等的；


webpack是一个静态的模块化打包工具，为现代的JavaScript应用程序；
我们来对上面的解释进行拆解：
  打包bundler：webpack可以将帮助我们进行打包，所以它是一个打包工具
  静态的static：这样表述的原因是我们最终可以将代码打包成最终的静态资源（部署到静态服务器）；
  模块化module：webpack默认支持各种模块化开发，ES Module、CommonJS、AMD等；
  现代的modern：我们前端说过，正是因为现代前端开发面临各种各样的问题，才催生了webpack的出现和发展；


JavaScript的打包：
  将ES6转换成ES5的语法；      babel可转换，但是是手动的，我们可将其集成到webpack里进行自动转化
  TypeScript的处理，将其转换成JavaScript；
Css的处理：
  CSS文件模块的加载、提取；
  Less、Sass等预处理器的处理；
资源文件img、font：
  图片img文件的加载；
  字体font文件的加载；
HTML资源的处理：
  打包HTML资源文件；
处理vue项目的SFC文件.vue文件；


webpack的官方文档是https://webpack.js.org/
  webpack的中文官方文档是https://webpack.docschina.org/
  DOCUMENTATION：文档详情，也是我们最关注的

Webpack的运行是依赖Node环境的，所以我们电脑上必须有Node环境
  所以我们需要先安装Node.js，并且同时会安装npm；
  我当前电脑上的node版本是v16.15.1，npm版本是8.11.0（你也可以使用nvm或者n来管理Node版本）；
  Node官方网站：https://nodejs.org/


◼ webpack的安装目前分为两个：webpack、webpack-cli       webpack是实际用来执行打包操作的，可在代码中使用，webpack-cli是借助于命令行使用webpack的桥梁

◼ 那么它们是什么关系呢？
  执行webpack命令，会执行node_modules下的.bin目录下的webpack；
  webpack命令在执行时是依赖webpack-cli的，如果没有安装就会报错；
  而webpack-cli中代码执行时，才是真正利用webpack进行编译和打包的过程；
  所以在安装webpack时，我们需要同时安装webpack-cli（第三方的脚手架事实上是没有使用webpack-cli的，而是类似于自己的vue-service-cli的东西）

  运行webpack命令时，是执行  node_modules/.bin下的webpack，而它是依赖webpack-cli的runCli函数，然后就会依赖webpack打包


  npm init -y
  -y 的含义：yes的意思，在init的时候省去了敲回车的步骤，生成的默认的package.json
  倘若用npm init 则还需要填包名、描述等一系列内容


  npx webpack  使用局部的webpack进行打包，默认的入口文件是 index.js，即会从index.js入手，搜寻依赖进行打包，即利用命令行 npx webpack，它会默认找src下的index.js，找不到则报错   npx webpack打包的默认输出文件夹，文件名为  dist/main.js

  想要修改默认打包入口，则需要给 npx webpack 添加参数，如  npx webpack --entry ./src/main.js 此时入口为  main.js
  想要修改默认打包出口，则需要给 npx webpack 添加参数，如  npx webpack --entry ./src/main.js --output-path ./build --output-filename bundle.js   此时文件会打包到  build/bundle.js

此时，命令太长，需要提取，我们可以单独创建一个配置文件，默认会读取的配置文件是  webpack.config.js  其内部的配置写法也是固定的  webpack是跑在node上面的，因此其模块化需要用node的，即common.js  有了配置之后，打包可直接写为 npx webpack  敲完命令后，webpack会到src下找webpack.config.js，然后是用它的配置

倘若配置文件不想用使用webpack.config.js，我们也可以 给npx webpack 加参数  npx webpack --config rcWk.config.js  此时会使用 rcWk.config.js 的配置

最后可将命令写到package.json中，然后利用 npm run 即可



◼ webpack到底是如何对我们的项目进行打包的呢？
  事实上webpack在处理应用程序时，它会根据命令或者配置文件找到入口文件；
  从入口开始，会生成一个 依赖关系图，这个依赖关系图会包含应用程序中所需的所有模块（比如.js文件、css文件、图片、字体等）；
  然后遍历图结构，打包一个个模块（根据文件的不同使用不同的loader来解析）
  webpack本身可以处理打包js(但是不会将es6代码转化为es5)，其他的文件则需要对应的loader


loader配置方式
◼ 配置方式表示的意思是在我们的webpack.config.js文件中写明配置信息：
   module.rules中允许我们配置多个loader（因为我们也会继续使用其他的loader，来完成其他文件的加载）；
   这种方式可以更好的表示loader的配置，也方便后期的维护，同时也让你对各个Loader有一个全局的概览；
◼ module.rules的配置如下：
◼ rules属性对应的值是一个数组：[Rule]
◼ 数组中存放的是一个个的Rule，Rule是一个对象，对象中可以设置多个属性：
   test属性：用于对 resource（资源）进行匹配的，通常会设置成正则表达式；
   use属性：对应的值时一个数组：[UseEntry]
    ✓ UseEntry是一个对象，可以通过对象的属性来设置一些其他属性
      ➢ loader：必须有一个 loader属性，对应的值是一个字符串；
      ➢ options：可选的属性，值是一个字符串或者对象，值会被传入到loader中；
      ➢ query：目前已经使用options来替代；
    ✓ 传递字符串（如：use: [ 'style-loader' ]）是 loader 属性的简写方式（如：use: [ { loader: 'style-loader'} ]）；
   loader属性： Rule.use: [ { loader } ] 的简写。


在webpack中使用postcss，则是利用postcss-loader，相关的配置可抽离到postcss.config.js


对图片打包
我们当前使用的webpack版本是webpack5：
  在webpack5之前，加载这些资源我们需要使用一些loader，比如raw-loader 、url-loader、file-loader；
  在webpack5开始，我们可以直接使用资源模块类型（asset module type），来替代上面的这些loader；

资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：

  asset/resource 发送一个单独的文件并导出 URL。
    ✓ 之前通过使用 file-loader 实现；

  asset/inline 导出一个资源的 data URI。
    ✓ 之前通过使用 url-loader 实现；

  asset/source 导出资源的源代码
    ✓ 之前通过使用 raw-loader 实现；

  asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。
    ✓ 之前通过使用 url-loader，并且配置资源体积限制实现；



对js打包
Babel是一个工具链，主要用于旧浏览器或者环境中将ECMAScript 2015+代码转换为向后兼容版本的JavaScript；包括：语法转换、源代码转换等

babel本身可以作为一个独立的工具（和postcss一样），可以不和webpack等构建工具配置来单独使用。
如果我们希望在命令行尝试使用babel，需要安装如下库：
  @babel/core：babel的核心代码，必须安装；
  @babel/cli：可以让我们在命令行使用babel；

  npm install @babel/cli @babel/core -D

◼ 使用babel来处理我们的源代码：
  src：是源文件的目录；
  --out-dir：指定要输出的文件夹dist；

  npx babel src --out-dir dist

默认直接使用babel时，和postcss一样，不会有效果，若要实现具体效果，需要安装对应插件

比如我们需要转换箭头函数，那么我们就可以使用箭头函数转换相关的插件：
npm install @babel/plugin-transform-arrow-functions -D
npx babel src --out-dir dist --plugins=@babel/plugin-transform-arrow-functions

plugin-transform-block-scoping插件，可将const转化为var，可将两个插件联合使用
npm install @babel/plugin-transform-block-scoping -D 
npx babel src --out-dir dist --plugins=@babel/plugin-transform-block-scoping
,@babel/plugin-transform-arrow-functions

安装@babel/preset-env预设：
◼ 执行如下命令：
npm install @babel/preset-env -D
npx babel src --out-dir dist --presets=@babel/preset-env


安装完vue-loader后，还必须添加@vue/compiler-sfc来对template进行解析，一般安装vue会自动对其安装
另外我们需要配置对应的Vue插件  VueLoaderPlugin  对应写在wk.config.js中


◼ resolve用于设置模块如何被解析：
  在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库；
  resolve可以帮助webpack从每个 require/import 语句中，找到需要引入到合适的模块代码；
  webpack 使用 enhanced-resolve 来解析文件路径；

webpack能解析三种文件路径：
◼ 绝对路径
  由于已经获得文件的绝对路径，因此不需要再做进一步解析。
◼ 相对路径
  在这种情况下，使用 import 或 require 的资源文件所处的目录，被认为是上下文目录；
  在 import/require 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径；
◼ 模块路径
  在 resolve.modules中指定的所有目录检索模块；
    ✓ 默认值是 ['node_modules']，所以默认会从node_modules中查找文件；
  我们可以通过设置别名的方式来替换初识模块路径，具体后面讲解alias的配置；

确实文件还是文件夹
◼ 如果是一个文件：
  如果文件具有扩展名，则直接打包文件；
  否则，将使用 resolve.extensions选项作为文件扩展名解析；
◼ 如果是一个文件夹：
  会在文件夹中根据 resolve.mainFiles配置选项中指定的文件顺序查找；
    ✓ resolve.mainFiles的默认值是 ['index']； 即现在路径后添加index
    ✓ 再根据 resolve.extensions来解析扩展名；

◼ extensions是解析到文件时自动添加扩展名：
  默认值是 ['.wasm', '.mjs', '.js', '.json']；
  所以如果我们代码中想要添加加载 .vue 或者 jsx 或者 ts 等文件时，我们必须自己写上扩展名；
◼ 另一个非常好用的功能是配置别名alias：
  特别是当我们项目的目录结构比较深的时候，或者一个文件的路径可能需要 ../../../这种路径片段；
  我们可以给某些常见的路径起一个别名；


Loader是用于特定的模块类型进行转换；
Plugin可以用于执行更加广泛的任务，比如打包优化、资源管理、环境变量注入等
  环境变量注入： 如DefinePlugin 可以全局给js添加变量，则任意js文件可使用改变量


简单设置一个mode，其实相当于设置了很多内容


自动对本地代码打包且不会生成对应的output文件而是将之放在内存里，然后搭建服务器并从内存中读取内容放入服务器，并监听代码的改变，并自动编译、刷新浏览器，可用  webpack-dev-server
◼ 安装webpack-dev-server
◼ 修改配置文件，启动时加上serve参数：
  devServer: {

  }
  使用命令： webpack serve --config wk.config.js
◼ webpack-dev-server 在编译之后不会写入到任何输出文件（因为这样需要写入磁盘，使用时还需读取，相对于放在内存中效率太低），而是将 bundle 文件保留在内存中：
  事实上webpack-dev-server使用了一个库原本叫memfs（memory-fs webpack自己写的）



webpack-dev-server 的操作是  任何一个模块发生改变，整个的内容都会改变，影响效率，故我们想当改变某一个模块时，仅仅该模块发生替换，此时我们需要使用HMR
  HMR的全称是Hot Module Replacement，翻译为模块热替换；
  模块热替换是指在 应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个页面

  HMR通过如下几种方式，来提高开发的速度：
  不重新加载整个页面，这样可以保留某些应用程序的状态不丢失；
  只更新需要变化的内容，节省开发的时间；
  修改了css、js源代码，会立即在浏览器更新，相当于直接在浏览器的devtools中直接修改样式；

  默认情况下，webpack-dev-server已经支持HMR，我们只需要开启即可（默认已经开启）；
  在不开启HMR的情况下，当我们修改了源代码之后，整个页面会自动刷新，使用的是live reloading

  devServer: {
    hot: true
  }
  你会发现，当我们修改了某一个模块的代码时，依然是刷新的整个页面：
  这是因为我们需要去指定哪些模块发生更新时，进行HMR
写在main.js中：
if(module.hot) {
  module.hot.accept("./util.js", () => {
    console.log("util更新了")
  })
}
注意：倘若别的地方使用了该模块，则webpack-dev-serve会认为其也受到影响，有发生改变，进而触发整个浏览器的更新

◼ 有一个问题：在开发其他项目时，我们是否需要经常手动去写入 module.hot.accpet相关的API呢？
  比如开发Vue、React项目，我们修改了组件，希望进行热更新，这个时候应该如何去操作呢？
◼ 事实上社区已经针对这些有很成熟的解决方案了：
  比如vue开发中，我们使用vue-loader，此loader支持vue组件的HMR，提供开箱即用的体验；
  比如react开发中，有React Hot Loader，实时调整react组件（目前React官方已经弃用了，改成使用react-refresh）


◼ host设置主机地址：
  默认值是localhost；
  如果希望其他地方也可以访问，可以设置为 0.0.0.0；

◼ localhost 和 0.0.0.0 的区别：
  localhost：本质上是一个域名，通常情况下会被解析成127.0.0.1; 127.0.0.1：回环地址(Loop Back Address)，表达的意思其实是我们主机自己发出去的包，直接被自己接收;
✓ 正常的数据库包经常 应用层 - 传输层 - 网络层 - 数据链路层 - 物理层 ;
✓ 而回环地址，是在网络层直接就被获取到了，是不会经常数据链路层和物理层的; 
✓ 比如我们监听 127.0.0.1时，在同一个网段下的主机中，通过ip地址是不能访问的;
  0.0.0.0：监听IPV4上所有的地址，再根据端口找到不同的应用程序;
✓ 比如我们监听 0.0.0.0时，在同一个网段下的主机中，通过ip地址是可以访问的

devServer中设置好host为localhost后，只有自己的主机通过相应设置的端口才可以接受我们发输出的数据包；host设置为0.0.0.0是，同一网段下，其他主机可通过发出数据包的主机的ip地址加上相应的端口号访问数据包


要想使用 webpack serve 命令，需要安装 webpack-dev-server